(* !!!!!!!!! autogenerated, don't edit !!!!!!!!! *)



(*---
Copyright: see LICENCE
  ---*)

(** General purpose GUI (Graphical user interface) library for Ocaml.

   Bogue is a lightweight and fast GUI for developing desktop applications,
   games, or for easy debugging of non-GUI programs.

   Bogue is entirely written in {{:https://ocaml.org/}ocaml} except for the
   hardware accelerated graphics library {{:https://www.libsdl.org/}SDL2}.

@version 20230328

@author Vu Ngoc San

@see <https://github.com/sanette/bogue> the source code on github

*)

(**
 {e This documentation is best viewed on
 {{:https://sanette.github.io/bogue/Bogue.html}this page}. (While on
 {{:https://ocaml.org/p/bogue/latest/doc/Bogue/index.html}ocaml.org} some links
 may be broken.)}
*)

(** {3 Quick start}

 For a quick start, see Bogue's {{:Principles.html}general principles}, the
 minimal {{!example}example}, and the
 {{:https://sanette.github.io/bogue-tutorials/bogue-tutorials/index.html}tutorials}.


    The main modules are

    - {!Main} (creating, running, and quitting your app),
    - {!Layout} (arranging widgets to form sophisticated interfaces like table,
    menus, etc.) and
    - {!Widget} (the building blocks, like labels, buttons, etc.).

   {!indexlist}


*)

(* ---------------------------------------------------------------------------- *)

(** {1 List of Modules}

    The only thing that [open Bogue] does is to bring these modules into your
    namespace. They have quite common names, so beware of conflict. In case of
    doubt, don't open [Bogue], and access the modules by using the [Bogue]
    prefix, for instance [Bogue.Widget.label]. The {!Widget} and {!Layout}
    modules are probably the ones that you will find yourself using the most, so
    it's a good idea to alias them:

{[module W = Bogue.Widget
module L = Bogue.Layout]}


{%html:<br><br>%}

*)



(** Theme variables.

    A number of variables control the appearance of your Bogue application. They
    are called {%html:<a href="#list">Theme variables</a>%}.  They take effect
    when you start your application up (no need to recompile).  For quick
    experimentation, they can be modified as environment variables, for instance
    in a terminal: {v export BOGUE_SCALE=2.5 v} They can also be saved in
    configuration files, and you may organize as many config files as you want
    into {e themes}.

{3:config Where are the config files?}

    The config files are all called [bogue.conf]. Several locations are used.
    Upon installing Bogue, a system wide Bogue share directory is created. If
    you used an {b opam} install, this will be {v $(opam var share)/bogue v} The
    share directory contains a [themes] directory, which itself contains a
    [default] dir.  This is where the default configuration file resides.

    However, {b if you want to modify the themes}, it is advisable to create
    your own Bogue share dir.  This personal Bogue dir should be
    [$(XDG_CONFIG_HOME)/bogue].  (If [$XDG_CONFIG_HOME] is not defined in your
    system, you may use [$HOME/.config/bogue]).  So, this is what you can do for
    creating your personal Bogue dir for the first time: {v cp -r $(opam var
    share)/bogue $HOME/.config/bogue v}


    - Each theme has its own directory inside the Bogue share dir, in which
    there is a [bogue.conf] file where the Theme variables are defined.

    - A global user config file [$HOME/.config/bogue/bogue.conf] overrides the
    theme files.

    - A [bogue.conf] file in the same directory as the executable overrides the
    other config files.

    - The syntax of the config file is [VARIABLE = value], one entry per line.
    Notice the spaces surrounding [=]. Comment lines starting by [#] are
    ignored.  For instance:
{v
## BOGUE version 20220115
THEME = dark
BACKGROUND = color:azure
v}
    The first line <code>## BOGUE version XXX</code> is compulsory.

{3:list Here is the list of Theme variables:}

- [BACKGROUND]: the default background for all windows. It can be a color
  (eg. [color:darkturquoise] or [color:#00CED1]), or an image file
  (eg. [file:myimage.png]). See {%html:<a href="#path">below</a>%}
  for how to specify paths.
- [BG_COLOR]: a background color (eg. [darkturquoise], or [#00CED1])
  that is used by default by some widgets/layouts.
  It should be clearly visible over the [BACKGROUND].
- [BUTTON_COLOR_ON]: the color of active buttons.
- [BUTTON_COLOR_OFF]: the color of inactive buttons.
- [CHECK_ON]: the image used for the 'checked' icon. It can be a file
  (eg. [myimage.png]) or a font-awesome icon (eg. [fa:check-square-o]).
- [CHECK_OFF]: the image used for the 'unchecked' icon. See [CHECK_ON].
- [CURSOR_COLOR]
- [DIR]: the directory containing the themes subdirectories.
  Default: auto-detected at startup, usually [$HOME/.config/bogue/themes]
- [FA_DIR]: the fontawesome directory inside [DIR/common/].
- [FAINT_COLOR]: a non-obtrusive color for disabled options or
  text of little importance.
- [LABEL_COLOR]: the color for text or icon labels.
- [LABEL_FONT]: path of a TTF font for text labels.
  If your system has [fontconfig], any installed font (as listed by [fc-list])
  can be specified without the full path. Eg: [Ubuntu-R.ttf].
- [LABEL_FONT_SIZE]: integer, eg [14].
- [LOG_TO_FILE]: if "false", all log messages will appear on the console.
  If "true", the messages are instead sent to a log file, typically in the
  "/tmp" directory. Log files can be viewed on an ANSI terminal with
  [less -R] or with emacs using xterm-color-colorize-buffer
  (from the xterm-color package).
- [MENU_HL_COLOR]: the color for highlighting selected menu entries.
- [MENU_BG_COLOR]
- [MONO_FONT]: monospace font. See [LABEL_FONT].
- [OPENGL_MULTISAMPLE]: set to "true" to enable this opengl attribute.
- [ROOM_MARGIN]
- [SCALE]: global scale (any non-negative float). For instance if [SCALE = 2.],
  all dimensions given to Bogue functions will be multiplied by 2 before
  rendering to obtain
  the hardware size in pixels.
  If set to [0.] or not specified, it is autodetected to match your screen DPI
  (using [xdpyinfo], if present).
- [INT_SCALE]: set to "true" to force integer scale when using auto-detection.
  Some games may require this to avoid small graphics artifacts.
- [SEL_BG_COLOR]: background color for selected items in lists.
- [SEL_FG_COLOR]: text color for selected items in lists.
- [SMALL_FONT_SIZE]: integer. Used for instance for tooltips popups.
- [TEXT_COLOR]: color of standard text displays.
- [TEXT_FONT]: used for text displays. See [LABEL_FONT].
- [TEXT_FONT_SIZE]
- [THEME]: the name of the theme to use.
  It should be the name of the directory within the [themes] dir.
  As soon as this variable is set, all variables from that theme
  are loaded and override previously defined variables.
  If not specified, the default theme is initially loaded.

All variables with "COLOR" in their name can be specified either with RGB
hexadecimal like [#00CED1], or with a standard html name like [darkturquoise],
see {{:https://www.rapidtables.com/web/color/html-color-codes.html}this color
table}.

All variables can be overridden by setting the corresponding
environment variables, prepending "BOGUE_". For instance:
{v
export BOGUE_LABEL_COLOR=forestgreen
v}

{%HTML:<br>%}


{2:path How to load assets (images, sounds, etc.)}

When specifying a file to load, for instance
{v
BACKGROUND = file:background.png
v}
you need to specify where the file should be searched. Here are the rules:

First, the file is searched in current directory, then in the current theme's
directory (for instance [$HOME/.config/bogue/themes/default]), unless the file
string starts with [/], in which case it should be an absolute path
(eg. [file:/home/alice/myimage.png]). Finally, if the file string starts with
[%], for instance [file:%assets/images/bob.png], then the [%] char is replaced
by the Bogue dir, for instance
[file:/home/bob/.config/bogue/assets/images/bob.png].


{5 {{:graph-b_theme.html}Dependency graph}} *)
module Theme : sig

  (** {2 Accessing Theme variables}

      Theme variables are essentially for Bogue's internal use, but sometimes it
      can be useful to access or modify their values. See above for their
      description.

      {b Warning:} Theme variables are global variables and should be modified
      (by the main thread) {e before} starting the main loop (with {!Main.run})
      if you want predictable results. *)

  val room_margin : int

  val scale_int : int -> int
  (** Conversion: Bogue dimension -> hardware pixel dimension. The latter is
      obtained by multiplying by [SCALE].

      {b Warning:} Bogue scale is detected only when opening a window, typically
      when running {!Main.run}, or manually with {!Draw.video_init}. If you use
      [scale_int] too early you might end up with zeros... If you don't require
      auto-detection, you can use {!set_scale}. *)

  val set_text_font : string -> unit
  val set_label_font : string -> unit
  val set_scale : float -> unit

  val set_integer_scale : bool -> unit
    (** Set [INT_SCALE].  *)

  (** {2 Accessing files installed along with your application}

      Files distributed with your application built with Bogue should be
      installed in a "share" directory, for instance using the [install] stanza
      of [dune] with [(section share)].

      Another solution is to embed your files with the main binary using
      [ppx_blob](https://github.com/johnwhitington/ppx_blob). *)

  val find_share : string -> string -> string option
  (** [find_share app file] returns a guessed location for your application
      share directory (if it exists), for instance
      [/usr/local/share/my_app]. The [app] string should be the system name of
      your application (for instance [app="my_app"]). The returned location is
      guaranteed to contain the given [file]. If you don't have any file to
      search, you may use [file="."].

      {b Warning:} The directory returned by [find_share] is not necessarily
      writable. If you want a directory where the users of your application can
      save their preferences, you should rather use [Sdl.get_pref_path]. *)

end (* of Theme *)

(* ---------------------------------------------------------------------------- *)


(** Utilities.

    This module contains several utilities, in particular for debug logs.

{5 {{:graph-b_utils.html}Dependency graph}}
*)
module Utils : sig

  (** {2 Debugging} *)

  val printd : int -> ('a, unit, string, unit) format4 -> 'a
  (** For instance [printd debug_warning "The value x=%u is too big" x] will
     print a message in the console only if the {!debug} variable contains the
     [debug_warning] flag. *)

  val debug : bool ref
  val debug_code : int ref
  (** Logical {e ored} of [!debug] with debug flags (below) controls the amount
     of debuging. *)

  (** {3 Binary masks (=flags) for debugging messages.} *)

  val debug_thread : int
  val debug_warning : int
  val debug_graphics : int
  val debug_error : int
  val debug_io : int
  val debug_memory : int
  val debug_board : int
  val debug_event : int
  val debug_custom : int

  (** {2 Maths} *)

  val pi : float

  val round : float -> int
  (** Round float to nearest integer. *)

  val imax : int -> int -> int
  (** [imax a b] returns max([a], [b]). (Same as [Int.max]). *)

  val imin : int -> int -> int
  (** [imin a b] returns min([a], [b]). (Same as [Int.min]). *)

  (** {2 Tsdl Result} *)

  val go : 'a Tsdl.Sdl.result -> 'a
  (** Transform a [result] into a standard value, or fail with an error. Used
      for SDL functions only. *)

  (** {2 Options}

      Monadic style operations on optional variables. *)

  val map_option : 'a option -> ('a -> 'b) -> 'b option
  (** [map_option o f] is the same as [Option.map f o]. *)

  val do_option : 'a option -> ('a -> unit) -> unit
  (** [do_option o f] is the same as [Option.iter f o]. *)

  val default : 'a option -> 'a -> 'a
  (** [default o v ] is the same as [Option.value o ~default:v]. Warning: [v] is
      evaluated even if it is not used. *)


  exception None_option

  val remove_option : 'a option -> 'a
  (** Like [Option.get]. Warning: [remove_option None] will raise the
     {!None_option} exception. *)

  (** {2 Others} *)

  val ( let@ ) : ('a -> 'b) -> 'a -> 'b

  val run : (unit -> 'a) -> 'a
  (**  [run f] is equivalent to [f ()]. *)

end (* of Utils *)

(* ---------------------------------------------------------------------------- *)


(** Time in msec.

{5 {{:graph-b_time.html}Dependency graph}}
*)
module Time : sig
  type t = int

  val now : unit -> t
  (** Time elapsed from the initialization of SDL (roughly, since the start of
      your program). *)

  val adaptive_fps : ?vsync:bool -> int -> (unit -> unit) * (unit -> unit)
  (** Create helper functions to help controlling the frame rate of the graphics
      loop. This is only useful if you have your own graphics loop, and do not
      use {!Main.run}.

      [adaptive_fps 60] returns two functions [start,fps]. The statement
      [start ()] will start the timing.
      At each iteration of your loop, you should call
      [fps ()], which will try to sleep long enough to achieve the desired 60FPS
      rate. It works on average: if some frames take longer, it will shorten the
      next frame to keep up. However, it tries to be nice to the CPU: even if one
      is really too slow, it will guarantee a 5ms sleep to the CPU and {e not}
      try to keep up.

      [vsync] is [false] by default, when [true] it sets GL swap interval to [1]
      to wait for next vsync, and if it can't keep up with that during animation
      it will set swap interval to [-1] if supported by platform to use
      adaptive vsync.
      (which should avoid forcing the animation rate to an integer ratio of monitor refresh rate)

      @see {!Main.get_monitor_refresh_rate}
    *)

end (* of Time *)

(* ---------------------------------------------------------------------------- *)

(** Global variables with mutex.

   In a GUI, it is quite likely that a thread has to modify a variable
   owned by another thread. This is particularly true in Bogue
   (because connections created by {!Widget.connect} use a new Thread
   when executed, unless you specify [~priority:Main]). In order to
   protect against concurrent access to a shared variable, one should
   use a special kind of variable. This is the goal of this module.

   {b Warning:} working with threads is subtle, and using {!Var} will
   not magically make all problems disappear. In particular if two
   variables from two different threads want to access each other, you
   can end up into a stall, and freeze your program.  This can happen
   more often that one thinks, because a Var may contain a {!Layout},
   and we know that sometimes layouts want to modify themselves...

{5 {{:graph-b_var.html}Dependency graph}} *)
module Var : sig
  type 'a t

  val create : 'a -> 'a t
  (** [create v] returns a Var with initial value [v]. *)

  val get :  'a t ->  'a

  val set : 'a t ->  'a -> unit
    (** [set v value] waits until no thread is accessing the Var [v]
        and then sets its value to [value]. *)

  val with_protect : 'a t -> ('a -> 'b) -> 'b
  (** [with_protect v f] applies [f] to the value of [v], while protecting [v]
      from the access of any other thread. *)

  val protect_fn : 'a t -> ('a -> 'b) -> 'b
  (** @deprecated Same as {!with_protect}. *)

end (* of Var *)

(* ---------------------------------------------------------------------------- *)

(** Delayed actions.

{5 {{:graph-b_timeout.html}Dependency graph}}
*)
module Timeout : sig
  type t

  val add : int -> (unit -> unit) -> t
  (** [add delay action] will execute [action ()] (in the main thread) after the
      delay of [delay] ms.
     @return the Timeout element.

     Warning: don't expect the delay to be
     exact at the ms. The precision cannot be better than what the
     framerate imposes, {e i.e.} usually about 16ms.

      Note: it is legal for an action to add a new Timeout. *)

  val cancel : t -> unit
    (** Cancel the Timeout. *)
end (* of Timeout *)

(* ---------------------------------------------------------------------------- *)

(** Dealing with events.

    Events are simply SDL events, plus a few additional events. They are also
    used for primitive communication between threads.

    Events are detected by Layouts, and then sent to the resident
    Widget. Finally, the Widget decides what to do with the events. There is one
    exception: the {!startup} event is directly sent to all Widgets.

    {5 {{:graph-b_trigger.html}Dependency graph}} *)
module Trigger : sig
  type t = Tsdl.Sdl.event_type

  (** {2 SDL events} *)

  val text_input : t
  (** Same as Tsdl.Sdl.Event.text_input *)

  val key_down : t
  (** Same as Tsdl.Sdl.Event.key_down *)

  val key_up : t
  (** Same as Tsdl.Sdl.Event.key_up *)

  (** {2 Special Bogue events} *)

  val startup : t
  (** The [startup] event is sent to all Widgets when the Bogue mainloop is
     started using {!Main.run}. *)

  val mouse_enter : t
  (** The [mouse_enter] event is triggered when the pointer (mouse motion, or
     finger touch -- but not finger drag) enters a new layout. *)

  val mouse_leave : t
  (** Similar to {!mouse_enter}, when the pointer leaves the layout. *)

  val mouse_at_rest : t
  (** Triggered when the mouse did not move for a while. *)

  val var_changed : t
  (** The [var_changed] event can be sent to notify that some widget made a
     change to a global variable. *)

  val update : t
  (** Currently the [update] event is more or less equivalent to
     [var_changed]. This might change in future versions. *)

  val user_event : t
  (** Same as [Tsdl.Sdl.Event.user_event]. This special event of type
      SDL_UserEvent can trigger a global reaction, not associated with any
      widget in particular, through the [on_user_event] parameter of
      {!Main.create} *)

  val buttons_down : t list
  (** A list of events containing the mouse_button_down event, and the
     finger_down event. *)

  val buttons_up : t list
  (** A list of events containing the mouse_button_up event, and the
     finger_up event. *)

  val pointer_motion : t list
  (** A list of events containing the mouse_motion event, and the finger_motion
     event. *)

  (** {2 Using events for terminating threads} *)

  val should_exit : Tsdl.Sdl.event -> bool
  (** Tell if the current thread should exit. This should only be called within
     a widget action. The event should be the event passed to the action
     function. A well programmed action should check this event to decide if it
     should exit. *)
  (* à déplacer dans Widget/connection ? *)

  val will_exit : Tsdl.Sdl.event -> unit
  (** A nice thread should do this just before terminating. May be suppressed in
      future versions. *)

  val nice_delay : Tsdl.Sdl.event -> float -> unit
  (** [nice_delay ev t] Wait during a delay ([t] seconds), but quit anyway when
     {!should_exit}[ ev] is true. *)

  val push_quit : unit -> unit
  (** Send the SDL_QUIT event, as if the user clicked on the close button of the
     last existing window. It will in principle raise the {!Main.Exit}
     exception and hence exit the mainloop. *)

  (** {2 SDL Misc} *)
  val wait_for : ?timeout:float -> ?ev:Tsdl.Sdl.event -> (unit -> bool) -> unit

  (** {2 SDL events} *)

  type sdl_event = Tsdl.Sdl.Event.enum

  type bogue_event =
    [ `Bogue_startup
    | `Bogue_stop
    | `Bogue_stopped
    | `Bogue_mouse_at_rest
    | `Bogue_mouse_enter
    | `Bogue_mouse_leave
    | `Bogue_var_changed
    | `Bogue_keyboard_focus
    | `Bogue_mouse_focus
    | `Bogue_remove_layout
    | `Bogue_destroy_window
    | `Bogue_update
    | `Bogue_sync_action
    | `Bogue_redraw
    | `Bogue_keymap_changed
    ]

  val event_kind : Tsdl.Sdl.event -> [sdl_event | bogue_event]
  (** Union of {!sdl_event} and {!bogue_event} *)

end (* of Trigger *)

(* ---------------------------------------------------------------------------- *)

(** Basic audio mixer for sound effects.

    This simple audio mixer makes it possible to play quick sounds, for instance
    when clicking on buttons, or for game sounds effects.

    Only WAV files are supported. For playing MP3 music, and for more options,
    it is advisable to use the SDL_Mixer library.

    {e Remark:} This module is essentially independent of the rest of Bogue, so
    its source can, with very few modifications, be used for any SDL
    application.

    {e Remark:} Under Windows, using WLS2, it was reported that sound works if
    [wslg] is installed.

    {5 {{:graph-b_mixer.html}Dependency graph}} *)
module Mixer : sig
  type t
  type sound =  (int, Bigarray.int16_signed_elt) Tsdl.Sdl.bigarray
  type repeat = Repeat of int | Forever
  (* How many times we should repeat the sound. *)

  val test : unit -> unit

  val init : unit -> string option
  (** Initialize SDL audio.
      @return the name of the audio driver, or [None] if no audio is
        available. *)

  val create_mixer : ?tracks:int -> ?freq:int -> string option -> t
  (** [create devname] creates the mixer an opens the sound device. If [devname]
      is [None], a dummy mixer is returned, which will produce no sound. Only
      [s16le] format is supported by the callback at this time. The mixer is
      initially paused, you need to {!unpause} it before playing anything. *)

  val load_chunk : t -> string -> sound
  (** Load a WAV file. *)

  val play_chunk : ?track:int ->
    ?effects:(sound -> unit) list ->
    ?volume:float -> ?repeat:repeat -> t -> sound -> int option
  (** Play chunk on the desired track number. If [track] is not specified, find
     an available track. By default [repeat = Repeat 1].
     @return chosen track number, or None *)

  val change_volume : float -> sound -> unit
  (** Multiply sound intensity by a float factor *)

  val pause : t -> unit
  val unpause : t -> unit
  val close : t -> unit

end (* of Mixer *)

(* ---------------------------------------------------------------------------- *)

(** Synchronized execution queue.

    Any action can be pushed to this FIFO queue, in order to be executed by
    Bogue's main loop at the start of the next graphical frame.

    For any action that is not super urgent, it is a good idea to use this
    `Sync` module, instead of launching the action directly from a thread that
    may be difficult to control. In this way, we ensure that the action is not
    executed in the middle of rendering the graphics, or between various
    modifications of the board (events, keyboard focus, etc.).

    {5 {{:graph-b_sync.html}Dependency graph}} *)
module Sync : sig

  val push : (unit -> unit) -> unit
  (** [push action] registers the [action] to be executed by the mainloop at the
      start of the next frame, or at a subsequent frame if the queue is already
      large.

      {b Warning:} the action should not call {!push} itself, otherwise this will
      result in a deadlock. *)

end (* of Sync *)

(* ---------------------------------------------------------------------------- *)

(** Low-level graphics and colors.

    This module is internally used for low-level graphics and a thin layer over
    Tsdl.

    The public API is mainly useful for Color management. There are also some
    helper functions for drawing into an {!Sdl_area}.

    {5 {{:graph-b_draw.html}Dependency graph}} *)
module Draw: sig
  type canvas
  (** Contains the hardware information for drawing (SDL renderer and
      window). *)

  type texture = Tsdl.Sdl.texture

  (** {2 Initialization and shutdown} *)

  val video_init : unit -> unit
  (** Manually init the SDL video system, and detect the scaling factor used by
      Bogue. This is useful only if you don't use Bogue's mainloop (for instance
      if you manually manage your windows and event loop). *)

  val quit : unit -> unit
  (** Cleanup and quit SDL. *)

  (** {2 Colors} *)

  type rgb = int * int * int
  (** red, green and blue values are integers in the range [0..255] *)

  type color = int * int * int * int
  (** r,g,b,a *)

  type fill =
    | Pattern of texture
    | Solid of color

  (** {3 Predefined colors} *)

  val black : rgb
  val grey : rgb
  val pale_grey : rgb
  val dark_grey : rgb
  val white : rgb
  val red : rgb
  val blue : rgb
  val green : rgb
  val magenta : rgb
  val cyan : rgb
  val yellow : rgb
  val sienna : rgb

  val label_color : rgb

  val none : color
  (** [none = (0,0,0,0)] is completely transparent black. *)

  (** {3 Creating colors} *)

  val opaque : rgb -> color
  val transp : rgb -> color
  val lighter : color -> color
  val darker : color -> color
  val set_alpha : int -> rgb -> color
  val random_color : unit -> color
  val find_color : string -> rgb
  (** Convert a string of the form ["grey"] or ["#FE01BC"] to a rgb code
     [(r,g,b)]. Color names are taken from
     {{:https://www.rapidtables.com/web/color/html-color-codes.html}here}. *)

  val pale : rgb -> rgb

  (** {3 Using colors} *)

  val set_color : Tsdl.Sdl.renderer -> color -> unit
  (** Equivalent to [Sdl.set_render_draw_color]. *)

  val set_text_color : rgb -> unit
  (** Overrides the {!Theme} [TEXT_COLOR] variable. *)

  (** {2:drawing_functions Drawing functions}

      These functions can be used to draw onto an {!Sdl_area.t}. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into hardware pixel coordinates. This
      takes into account both the {!Theme} [SCALE] and the high-dpi scaling of
      some systems (mac OS retina, iOS). *)

  val line : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> x0:int -> y0:int -> x1:int -> y1:int -> unit

  val rectangle : ?thick:int -> Tsdl.Sdl.renderer -> color:color ->
    w:int -> h:int -> x:int -> y:int -> unit
  (** [rectangle renderer ~color ~thick ~w ~h ~x ~y] draws a rectangle with
      given line thickness. The coordinate of the top left corner is
      [(x,y)]. The size (including the thick line) is [(w,h)]. *)

  val circle : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> radius:int -> x:int -> y:int -> unit
  (** [circle renderer ~width ~color ~radius ~x ~y] draws a circle with given
      line thickness, centered at [(x,y)], with given [radius]. *)

  (**/**)
  (** {2 Layers} *)

  (** Layers are used to decide the order of drawing: which graphical elements
      (layouts) should be below, which should be above. For the most part, you
      don't have to access them directly. *)
  type layer

  val use_new_layer : unit -> unit
  (** Use this when you want to switch to a completely different set of layers,
      typically when you want to draw on another window. *)
  (**/**)

  (** {2 Misc} *)

  type align =
    | Min
    | Center
    | Max

  val unscale_size : int * int -> int * int
  (** Transform a size (W,H) in physical pixels into 'logical' pixels (w,h),
     which are used for layouts. This is done by dividing by the {!Theme}
     [SCALE] variable. *)

  val set_system_cursor : Tsdl.Sdl.System_cursor.t -> unit
  (** Set the mouse cursor to be the standard system cursor.  Internally, this
      first creates an SDL system cursor (or use a previously created one). *)

end (* of Draw *)

(* ---------------------------------------------------------------------------- *)

(** Mouse and touchscreen information.

All positions are given in logical pixels, not hardware pixels (see the {!Theme}
   [SCALE] variable).

{5 {{:graph-b_mouse.html}Dependency graph}} *)
module Mouse : sig

  val pointer_pos : Tsdl.Sdl.event -> int * int
  (** Return the pointer current position. This works both for mouse and
     touchscreen. *)

  val pos : unit -> int * int
  (** Get current mouse position. *)

  val window_pos : Tsdl.Sdl.window -> int * int
(** Return the mouse position with respect to the given window, using window
   position if necessary. *)

  val button_pos : Tsdl.Sdl.event -> int * int

  val finger_pos : Tsdl.Sdl.event -> float * float


end (* of Mouse *)

(* ---------------------------------------------------------------------------- *)


(** Transform variables

    Transform variables are a way to share a common data between two widgets,
   when the data has a different meaning (or even a different type) for each
   widget. One widget holds the original value, and the other widget needs to
   apply a {e transformation} each time it wants to read or modify the value.

    For instance you want to share a bank account [b] between Alice in France
   and Bob in the USA. The value is stored by Alice in EUR, and when Bob does
   [get b], he gets the value in USD. Similarly, if he does [set b 50] to put
   50USD on the account, then Alice's value will automatically have the amount
   in EUR.

    What is interesting is that the transformation functions can also have {e
   side-effects}. For instance, send an email each time Bob or Alice modifies
   the amount.

    A more prosaic example would be a slider which shares its value as an
   integer between 0 and 100, and another widget which needs to read/save this
   value as a float between 0 and 1, and each one of them gets notified when the
   other changes the value.

{5 {{:graph-b_tvar.html}Dependency graph}} *)
module Tvar : sig
  type ('a, 'b) t
  (** a transform variable of type [('a,'b)] is a variable of type ['b] attached
     to a variable of type ['a Var.t] by a bi-directional transformation. *)

  val create : 'a Var.t -> t_from:('a -> 'b) -> t_to:('b -> 'a) -> ('a, 'b) t
  val get : ('a, 'b) t -> 'b
  val set : ('a, 'b) t -> 'b -> unit

end (* of Tvar *)

(* ---------------------------------------------------------------------------- *)

(** Animated variables.

    An Avar.t is a variable that evolves in time. It is updated at every frame
   ({e i.e.} every iteration of the main loop). Bogue uses Avars for animations.

{5 {{:graph-b_avar.html}Dependency graph}} *)
module Avar : sig
  type 'a t

  type callback = unit -> unit

  (** {2 Avar creation} *)

  val create : ?duration:Time.t ->
    ?init:callback ->
    ?ending:callback ->
    ?finished:bool -> ?update:('a t -> float -> 'a) -> 'a -> 'a t
  (** Generic Avar creation. If [finished = true], the var never gets further
     updated, {e ie} behaves like a normal variable. Otherwise, the [update]
     parameter is compulsory.

     @param update is a function such that [update v s : 'a] should give the
     value of the Avar [v] at the time [s]. The meaning of the time [s] is
     described in {!progress}. *)

  val apply : ('a -> 'b) -> 'a t -> 'b t
      (** [apply f v] creates a new Avar by composing with f; the old Avar [v]
          is still active *)

  val fromto : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** [fromto x1 x2] creates a integer Avar.t with initial value [x1] and, as
      time elapses, moves continuously to [x2], with a final slowdown. *)

  val fromto_unif : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** Similar to {!fromto} but with uniform speed (no slowdown). *)

  val oscillate : ?duration:int -> ?frequency:float -> int -> int -> int t
  (** [oscillate amplitude x0] will oscillate with the given amplitude around
      the initial value [x0] *)

  val var : 'a -> 'a t
  (** Create an Avar which behaves like a normal Var (no animation). *)

  (** {2 Avar information} *)

  val get : 'a t -> 'a
  (** Start the animation (if necessary) and compute the current value of the
     variable. *)

  val progress : 'a t -> float
  (** [progress v] is a float in \[0,1\] giving the percentage of the animation
     when the last [v.value] was computed. In case of infinite animation, this
     is just the elapsed Time (in ms). *)

  (** {2 Misc} *)

  type direction =
    | No
    | Left
    | Right
    | Top
    | Bottom
    | TopLeft
    | TopRight
    | BottomLeft
    | BottomRight
    | Random
end (* of Avar *)

(* ---------------------------------------------------------------------------- *)

(** Unions of ranges of integers

{3:selection_example Example}

We define two sets, [s=[0..5; 10..20]] and [r=[4..15]],
and we compute their union and intersection.

{[
open Bogue.Selection;;
# let s = of_list [(0,5); (10,20)];;
val s : t = <abstr>
# sprint s;;
- : string = "{0..5, 10..20}"
# let r = of_list [(4,15)];;
val r : t = <abstr>
# sprint (union s r);;
- : string = "{0..20}"
# sprint (intersect s r);;
- : string = "{4..5, 10..15}"
]}

{5 {{:graph-b_selection.html}Dependency graph}}
 *)
module Selection : sig
  type t
  val to_list : t -> (int * int) list
  val of_list : (int * int) list -> t
  val mem : t -> int -> bool
  val toggle : t -> int -> t
  val remove : t -> int -> t
  val add : t -> int -> t
  val union : t -> t -> t
  val intersect : t -> t -> t
  val sprint : t -> string
  val iter : (int -> unit) -> t -> unit

end (* of Selection *)

(* ---------------------------------------------------------------------------- *)

(** {2 Widgets}

    Widgets are building blocks of the GUI. They also receive all events (mouse
   focus, etc.) and contain the {e intelligence} of your GUI, through {e
   connections} (or callbacks, see {!Widget.connection}). However, in order to
   be displayed, they need to be packed into {e layouts} ({!Layout.t}).

   The main module for dealing with widgets is {!Widget}.
*)

(** Image widget.

{5 {{:graph-b_image.html}Dependency graph}}
 *)
module Image : sig
  type t

  val create : ?width:int -> ?height:int -> ?noscale:bool -> ?bg:Draw.color ->
    ?angle:float -> string -> t
  (** [create "image.jpg"] will load the image ["image.jpg"]. The actual load
      occurs only once, on the first time the image widget is effectively
      displayed. The image is then stored in a texture. All
      {{:https://wiki.libsdl.org/SDL_image/FrontPage}Sdl_image} image formats are
      supported.

      The file "image.png" will be search in the current Theme
      directory. Absolute paths starting with "/" can also be used.

      @param noscale if [true], the image will appear at the original hardware
      pixel size. By default, [noscale=false] and the image is scaled using the
      {!Theme} [SCALE] variable. *)

  val create_from_svg : ?width:int -> ?height:int -> ?bg:Draw.color -> string -> t
  (** Load an svg image. This requires the [rsvg] or [rsvg-convert] program.

      {e Remark:} With SDL_Image >= 2.0.2, one can use {!create} to load SVG
      files, but the size is not correctly handled (the image will be rendered at
      its 'internal SVG size', and {e then} scaled, which may result in poor
      accuracy).

  *)

end (* of Image *)

(* ---------------------------------------------------------------------------- *)

(** Line and box styles.

{5 {{:graph-b_style.html}Dependency graph}}
 *)
module Style : sig
  type t

  (** not implemented *)
  type line_style =
    | Solid
    | Dotted of (int * int)

  type line
  type border
  type shadow
  type gradient
  type background =
  | Image of Image.t (** pattern image *)
  | Solid of Draw.color
  | Gradient of gradient

  val create : ?background:background -> ?border:border ->
    ?shadow:shadow -> unit -> t
  val empty : t

  val of_bg : background -> t
  val of_border : border -> t
  val of_shadow : shadow -> t
  val with_bg : background -> t -> t
  val with_border : border -> t -> t
  val with_shadow : shadow -> t -> t

  (** {2 Constructing backgrounds} *)

  val theme_bg : background
  val color_bg : Draw.color -> background
  val opaque_bg : Draw.rgb -> background
  val image_bg : Image.t -> background
  val gradient : ?angle:float -> Draw.color list -> background
  val hgradient : Draw.color list -> background
  val vgradient : Draw.color list -> background

    (** {2 Constructing borders} *)

  val mk_line : ?color:Draw.color -> ?width:int ->
    ?style:line_style -> unit -> line
  val mk_border : ?radius:int -> line -> border
  (** Note: currently, a border with positive [radius] is not compatible with a
     transparent background. *)
  (* One could optionally make it possible by using [mask_texture] instead of
     [fast_mask_texture] in box.ml *)

  (** {2 Constructing shadows} *)

  val mk_shadow : ?offset:int * int -> ?size:int -> ?width:int ->
    ?radius:int -> unit -> shadow

end (* of Style *)

(* ---------------------------------------------------------------------------- *)

(** One-line text widget.

A [Label] is a widget for displaying a single line of text.

{5 {{:graph-b_label.html}Dependency graph}}
 *)
module Label : sig
  type t
  type font
  type style

  val create : ?size:int -> ?font:font -> ?style:style ->
               ?fg:Draw.color -> ?align:Draw.align -> string -> t
  (** Create a new {!Label.t}. Most of the time, you'd rather want to create a
     {!Widget.t} by using {!Widget.label}. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a {!Label.t} using the name of a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} symbol.  Most
     of the time, you'd rather want to create a {!Widget.t} by using
     {!Widget.icon}. *)

  val set : t -> string -> unit
  (** Modify the text of the label. Does nothing if the given text is already
     the same as the label's previous text. *)

  val set_fg_color : t -> Draw.color -> unit
  (** Modify the color of the text. *)

  val size : t -> int * int
  (** Return the logical size (w,h).
      Warning, a +/- 1 error can be observed due to rounding. *)

end (* of Label *)

(* ---------------------------------------------------------------------------- *)

(** Button widget with text or icon.

{5 {{:graph-b_button.html}Dependency graph}}
*)
module Button : sig
  type t
  type kind =
    | Trigger (* The button always looks "up" when not pressed.*)
    | Switch (* The button is displayed differently on "down" or "up". *)

  val create : ?size:int ->
    ?border_radius:int ->
    ?border_color:Draw.color ->
    ?fg:Draw.color ->
    ?bg_on:Style.background ->
    ?bg_off:Style.background ->
    ?bg_over:(Style.background option) ->
    ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t -> ?state:bool ->
    ?action:(bool -> unit) -> kind -> string -> t
    (** The [action] parameter is executed (with the current button state as
        argument) just after the button state is modified by mouse clicking or
        keyboard (on button up or key up). In order to execute an action that
        depends on the button itself, use {!Widget.on_button_release}
        instead. *)

  val state : t -> bool
  val reset : t -> unit
  val is_pressed : t -> bool
end (* of Button *)

(* ---------------------------------------------------------------------------- *)

(** Slider widget.

{5 {{:graph-b_slider.html}Dependency graph}}
 *)
module Slider : sig
  type t
  type  kind =
    | Horizontal (* horizontal bar with a small slider; NO background *)
    | HBar (* horizontal bar filled up to the value *)
    | Vertical
    | Circular

  val size : t -> int * int

  val value : t -> int
  (** Get current value. *)

  val get_max : t -> int

  val set : t -> int -> unit
  (** Set a new value. *)

end (* of Slider *)

(* ---------------------------------------------------------------------------- *)

(** Checkbox widget.

{5 {{:graph-b_check.html}Dependency graph}}
 *)
module Check : sig
  type t
  type style

  val create :  ?state:bool -> ?style:style -> unit -> t
  val state : t -> bool

end (* of Check *)

(* ---------------------------------------------------------------------------- *)

(** Multi-line text display widget.

{5 {{:graph-b_text_display.html}Dependency graph}}
 *)
module Text_display : sig
  type t
  type words

  (** {2 Preparing the text} *)

  val example : words
  val raw : string -> words
  val bold : words -> words
  val italic : words -> words
  val normal : words -> words
  val underline : words -> words
  val strikethrough : words -> words
  val page : words list -> words list
  val para : string -> words
  val paragraphs_of_string : string -> words list

  (** {2 Creating the widget}

       Use {!Widget.text_display} or {!Widget.verbatim} for plain text, or
       {!Widget.rich_text} for "rich text" (containing bold, italics, etc. using
       the functions listed above.)
*)

  (** {2 Modifying the widget} *)

  val replace : by:t -> t -> unit
(** [replace ~by:t2 t1] replaces the text content of [t1] by the one of [t2]. See also {!Widget.get_text_display}. *)

  val update_verbatim : t -> string -> unit

end (* Text_display *)

(* ---------------------------------------------------------------------------- *)

(** One-line text-input widget.

{5 {{:graph-b_text_input.html}Dependency graph}}
 *)
module Text_input : sig
  type t
  type filter = string -> bool


  (** {2 Creating the widget}

       Use {!Widget.text_input}
  *)

  val uint_filter : filter
  val text : t -> string

end (* of Text_input *)

(* ---------------------------------------------------------------------------- *)

(** Box widget.

{5 {{:graph-b_box.html}Dependency graph}}
*)
module Box : sig
  type t

  val create : ?width:int -> ?height:int ->
    ?style:Style.t -> unit -> t

  val set_background : t -> Style.background -> unit

end (* of Box *)

(* ---------------------------------------------------------------------------- *)

(** SDL Area widget.

    You can use an Sdl_area widget to draw whatever you want using all the power
    of the
    {{:https://erratique.ch/software/tsdl/doc/Tsdl/Sdl/index.html#renderers}SDL
    renderer API}.

    Technically, an Sdl_area widget contains an SDL texture and sets it as a {e
    render target}.

    SDL commands are sent to the Sdl_area using {!add} (and stored in a command
    queue). You can also use {!add_get} in order to get a handle on the command
    in case you reserve the possibility to remove the command with
    {!remove_element}.

{5 {{:graph-b_sdl_area.html}Dependency graph}} *)
module Sdl_area : sig
  type t

  val create : width:int -> height:int ->
    ?style:Style.t -> ?timeout:int -> unit -> t
  (** Create an empty SDL area. Note that the given size [(width,height)] is the
      {e logical} pixel size of the area. The physical size, to be used for most
      SDL rendering functions, can be obtained with {!drawing_size}. *)

  val update : t -> unit
  (** Force the area to be re-drawn at the next graphics frame. *)

  val clear : t -> unit
  (** Clear the area (this removes all commands from the render queue). *)

  val add : t -> ?name:string -> (Tsdl.Sdl.renderer -> unit) -> unit
  (** [add area ~name f] adds the arbitrary command [f] to the render queue.
     The command should be fast, otherwise it will block the UI when the queue
     is executed. For long drawings, it's better to split them into many
     commands. If you need the possibility to remove a command later, use
      {!add_get} instead. *)

  val cache :  t -> unit
  (** This will insert a special command in the queue that will save the texture
     obtained at that point, and clear all previous commands in the
     queue. Commands added to the queue after the [cache] invocation are not
     removed. Further updates to the area will show the cached texture and then
     execute the rest of the queue. Use this only for performance reasons when
     the rendering queue uses a lot of power and/or time. *)

  val clear_cache : t -> unit
  (** Clear the graphics cache generated by the {!cache} command. It has no
     effect if no cache was created. Clearing the cache does {e not} restore the
     commands in the queue that were used to draw it. *)

  (** {2 Drawing functions and utilities}

      Shortcuts to some {%html:<a href="Bogue.Draw.html#drawing_functions">
      drawing functions</a>%} from the {!Draw} module.

      For more sophisticated shapes (and faster rendering), consider using the
      {{:https://github.com/fccm/tsdl-gfx}tsdl_gfx} external library or,
      better, the companion {{:https://github.com/sanette/bogue-cairo}bogue-cairo} library.  *)

  val drawing_size : t -> (int * int)
  (** Size in physical pixels of the target SDL texture on which you can
     draw. You may also use [Tsdl.Sdl.get_renderer_output_size], if used inside
      the Sdl_area command queue. *)

  val pointer_pos : t -> Tsdl.Sdl.event -> int * int
  (** Position of the pointer (mouse or touchscreen that has generated the
     event) in physical pixels, with respect to the top-left corner of the
     Sdl_area. Should be called only after the Sdl_area has been rendered. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into pixel coordinates usable for the
     SDL area. Same as {!Draw.to_pixels}. *)

  val draw_line : t -> color:Draw.color -> thick:int ->
    int * int -> int * int -> unit
  (** [draw_line c ~color ~thick (x1, y1) (x2, y2)] draws a line of given
      [color] and [thick]ness from point [(x1, y1)] to point [(x2, y2)]. *)

  val draw_rectangle : t -> color:Draw.color -> thick:int ->
    w:int -> h:int -> int * int -> unit
  (** [draw_rectangle c ~color ~thick ~w ~h x0 y0] draws a rectangle of the
        given line thickness {e inside} the box of top-left coordinates [(x0,
        y0)], width [w] and height [h]. *)

  val fill_rectangle : t -> color:Draw.color ->
    w:int -> h:int -> int * int -> unit

  val draw_circle : t -> color:Draw.color -> thick:int -> radius:int ->
    int * int -> unit
  (** [draw_circle c ~color ~thick ~radius (x0, y0)] draws a circle of the given
     line [thick]ness and [color] {e inside} the disc of center coordinates
     [(x0, y0)] and given [radius].


      An example of [draw_circle] is provided by Example #50 (it can be run from
     the terminal with [boguex 50]), which produces the following picture:

      {%html:<div class="figure"><img src="images/example50.png"></div>%}

      The source code for all [boguex] examples is
     {{:https://github.com/sanette/bogue/blob/master/examples/example.ml}here}.

  *)

  val fill_circle : t -> color:Draw.color -> radius:int -> int * int -> unit


  (** {2 Draw elements}

      The command queue can be manipulated. An element of this queue is called a
      [draw_element].  *)

  type draw_element

  val add_get : t -> ?name:string -> ?disable:bool -> (Tsdl.Sdl.renderer -> unit)
    -> draw_element
  (** Similar to {!add}, but returns the corresponding {!draw_element}.  If
     [disable] is true, the command will not be executed. *)

  val disable : draw_element -> unit
  (** Mark an element for skipping its execution. *)

  val enable : draw_element -> unit
  (** See {!disable}. *)

  val remove_element : t -> draw_element -> unit
  (** Remove the {!draw_element} from the command queue. *)

  val add_element : t -> draw_element -> unit
  (** Append the element to the end of the command queue. *)

  val has_element : t -> draw_element -> bool
  (** Check whether the element belongs to the command queue. *)

  (** {2 Direct access to the texture} *)

  val get_texture : t -> Tsdl.Sdl.texture option

  val set_texture : t -> Tsdl.Sdl.texture -> unit

end (* of Sdl_area *)

(* ---------------------------------------------------------------------------- *)

(** Creating widgets and giving life to them

Widgets are simple graphic elements that can react to user interaction. They are
   the inhabitants of your GUI house. When a widget is woken up by some event,
   it can talk to another widget by means of a [connection].

{5 {{:graph-b_widget.html}Dependency graph}} *)
module Widget : sig
  type t
  (** The type {!t} is a union of all kinds of widgets: Box, Button, Check box,
     Image, Label, Slider, Text display, and Text input, plus the Empty
     widget.

For instance, in the following code:
{[
let w = label "Hello" in
let l = get_label w in
...
]}
[w] has the generic {!t} type, while [l] has the specialized {!Label.t} type.
*)

  (** {2:connections Connections}

      A connection has a source widget and a target widget. When the source
     widget receives a specified event, the connection is activated, executing a
     specified function, which is called {!action}.

     An action is always executed in a new Thread (and hence will not block the
     GUI), unless the priority [Main] is specified.  *)

  type connection

  type action = t -> t -> Tsdl.Sdl.event -> unit
  (** An action is a function with three parameters [w1 w2 ev], where
     [w1] is the source widget, [w2] the target widget, and [ev] the event
     ({!Trigger.t}) that triggered the action.

     The action should regularly verify {!Trigger.should_exit}[ ev] and quickly
     exit when that function returns [true].
*)

  (** What happens when an event triggers an action while the same action (=
      same connection id) is already running? Several behaviours are possible,
      depending on the following {!action_priority} type. *)

  type action_priority =
    | Forget (** discard the new action *)
    | Join (** execute the new after the first one has completed *)
    | Replace (** kill the first action (if possible) and execute the second one
                 *)
    | Main (** run in the main program. So this is blocking for all subsequent
              actions *)

  val connect : t -> t -> action -> ?priority:action_priority ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** [connect source target action triggers] creates a connection from the
      [source] widget to the [target] widget, but does not register it ({e this
      may change in the future...}). Once it is registered (either by
      {!Main.create} or {!add_connection}), and assuming that the layout
      containing the source widget has {e focus}, then when an event [ev]
      matches one of the [triggers] list, the [action] is executed with
      arguments [source target ev].

      @param priority indicates the desired priority policy. Default is [Forget].

  *)

  val connect_main : t -> t -> action ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** Alias for [connect ~priority:Main]. Should be used for very fast actions
      that can be run in the main thread. *)

  val add_connection : t -> connection -> unit
  (** Registers the connection with the widget. This should systematically be
     done after each connection creation, when the connection is created {e
     after} {!Main.create}.

     Connections that are created {e before} {!Main.create} should rather be
     passed as argument to {!Main.create}, and {e not} via
     [add_connection]. Although this is not strictly necessary, this indicates
     that these connections are more 'pure' or at least more static, in the
     sense that they will not be modified by Bogue. These are usually much
     easier to debug.

     {e [add_connection] is separated from {!connect} because it is not pure: it
     mutates the widget. This might change in future versions.} *)

  val update : t -> unit
  (** [update w] asks the widget [w] to refresh at next frame. The most probable
     use of [update] is within the code of an {!action}. It can happen that the
     action modifies the visual state of a widget that is neither the source or
     the target, and then one needs to explicitly tell this widget to re-draw
     itself.  *)

  (** {3 Predefined connections} *)

  val on_release : release:(t -> unit) -> t -> unit
  (** [on_release ~release:f w] registers on the widget [w] the action [f],
      which will be executed when the mouse button is released on this widget.
      {e Uses [priority=Main]} *)

  val on_button_release : release:(t -> unit) -> t -> unit
  (** Similar to {!on_release} but specialised to button widgets. It also checks
      the key used to activate buttons (currently, the Return key). *)

  val on_click : click:(t -> unit) -> t -> unit
  (** {e Uses [priority=Main]} *)

  val mouse_over : ?enter:(t -> unit) -> ?leave:(t -> unit) -> t -> unit


  (** {2:widget_create Creation of Widgets}

As a general rule, widgets should be created using the functions below, which
belong to the Widget module and create an element of type {!t}. However, for
some specialized usage, additional features may be available from the widget
underlying module (eg. {!Label}, {!Box}, etc.). See the {{!inner}conversion
functions} below. *)

  (** {3 Simple boxes (rectangles)} *)

  val box :
     ?w:int -> ?h:int -> ?style:Style.t -> unit -> t
  (** Create a Box widget, which simply displays a rectangle, optionally with
     rounded corners and drop shadow. It is often used for the background of a
     group of widgets (i.e. a {!Layout.t}). *)

  (** {3 Check boxes}
      The standard on/off check boxes. *)

  val check_box : ?state:bool -> ?style:Check.style -> unit -> t
  val set_check_state : t -> bool -> unit

  (** {3 Text display}
      Use this for multi-line text. *)

  val text_display :  ?w:int -> ?h:int -> string -> t
  val rich_text : ?size:int -> ?w:int -> ?h:int -> Text_display.words list -> t
  val verbatim : string -> t

  val html : ?w:int -> ?h:int -> string -> t
  (** Display basic html text by interpreting the following tags:
      [<em>,</em>, <b>,</b>, <strong>,</strong>, <p>,</p>, <br>] *)

  (** {3 Labels or icons} *)

  val label : ?size:int -> ?fg:Draw.color -> ?font:Label.font ->
    ?align:Draw.align -> string -> t
  (** Create a Label widget with a one-line text. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a Label widget with a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} icon.

     For instance [icon ~size:24 "star"] creates a widget that displays the
     "fa-star" fontawesome icon. *)

  (** {3 Empty} *)

  val empty : w:int -> h:int -> unit -> t
  (** Create a widget that does not display anything but still gets focus and
     reacts to events. *)

  (** {3 Image} *)

  val image : ?w:int -> ?h:int -> ?bg:Draw.color ->
    ?noscale:bool -> ?angle:float -> string -> t
  (** Load image file. *)

  val image_from_svg : ?w:int -> ?h:int -> ?bg:Draw.color -> string -> t
  (** Requires [rsvg]. *)

  val image_copy : ?rotate:float -> t -> t
  (** Return a new "Image" widget linked to the same image (same underlying
     [Image.t], hence same texture.) *)

  (** {3 Text input} *)

  val text_input : ?text:string -> ?prompt:string ->
    ?size:int -> ?filter:Text_input.filter -> ?max_size:int -> unit -> t

  (** {3 Buttons} *)

  val button : ?kind:Button.kind -> ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t ->
    ?fg:Draw.color ->
    ?bg_on:Style.background -> ?bg_off:Style.background ->
    ?bg_over:(Style.background option) ->
    ?state:bool ->
    ?border_radius:int -> ?border_color:Draw.color ->
    ?action:(bool -> unit) -> string -> t

  (** {3 Sliders} *)

  val slider : ?priority:action_priority -> ?step:int -> ?value:int ->
    ?kind:Slider.kind ->
    ?var:(int Avar.t, int) Tvar.t ->
    ?length:int -> ?thickness:int -> ?tick_size:int -> ?lock:bool ->
    ?w:int -> ?h:int -> int -> t
  (* The size of the slider is given either by [w,h] or [length, thickness]. The
     interpretation of [length] and [thickness] depends on [kind]. *)

  val slider_with_action : ?priority:action_priority ->
    ?step:int -> ?kind:Slider.kind -> value:int -> ?length:int ->
    ?thickness:int -> ?tick_size:int -> action:(int -> unit) -> int -> t
  (** Create a slider that executes an action each time the local value of the
     slider is modified by the user. *)

  (** {3 Sdl Area} You can use an Sdl_area widget to draw whatever you want
     using all the power of the SDL Renderer API. *)

  val sdl_area : w:int -> h:int -> ?style:Style.t -> unit -> t
  (** See {!Sdl_area.create} regarding the size [(w,h)]. *)

  (** {2 Creation of combined widgets} *)

  val check_box_with_label : string -> t * t
  (** [let b,l = check_box_with_label text] creates a check box [b], a label
     [l], and connect them so that clicking on the text will also act on the
     check box. *)

  (** {2 Generic functions on widgets}

      These generic functions work on all types of widgets, and emit an error in
     the log (without raising any exception) whenever the type of the argument
     makes no sense for the function.

      These functions are very handy, but sometimes can hide a bug. For instance
     if you want to use [get_state t], while you know that [t] should always be
     of type [Button], then it will help debugging to use instead the slightly
     longer form {!Button.state}[ (get_button t)]. Indeed the latter will fail
     if [t] happens not to be a Button.

*)

  val get_state : t -> bool
  (** Query a boolean state. Works for Button and Check. *)

  val get_text : t -> string
  (** Return the text of the widget. Works for Button, TextDisplay, Label, and
     TextInput. *)

  val size : t -> int * int
  (** If the widget is not rendered yet, a default size may be returned instead
     of the true size. *)

  val set_state : t -> bool -> unit
  (** Set a boolean state. Works for Button and Check. *)

  val set_text : t -> string -> unit
  (** Change the text of a widget. Works for Button, TextDisplay, Label,
     and TextInput. *)

  val set_cursor : t -> Tsdl.Sdl.cursor option -> unit
  (** Set the cursor that should be displayed for this widget. Note that the Sdl
     functions for creating cursor are only available after SDL
     initialization. One can use a [Lazy] type or {!Sync.push} for delaying
     their execution. *)

  (** {2:inner Conversions from the generic Widget type to the specialized inner type}

     These functions raise [Invalid_argument] whenever their argument is not of
     the correct type.  *)

  val get_box : t -> Box.t
  val get_check : t -> Check.t
  val get_label : t -> Label.t
  val get_button : t -> Button.t
  val get_slider : t -> Slider.t
  val get_text_display : t -> Text_display.t
  val get_text_input : t -> Text_input.t
  val get_image : t -> Image.t
  val get_sdl_area : t -> Sdl_area.t

  (** {2 Generic actions} *)

  val map_text : (string -> string) -> action
  (** [map_text f] is a {!action} that replaces the text of the second widget
     by [f] applied to the text of the first widget. *)

end (* of Widget *)

(* ---------------------------------------------------------------------------- *)

(** Updating widgets

{5 {{:graph-b_update.html}Dependency graph}}
*)
module Update : sig

  val push : Widget.t -> unit
  (** Register a widget for being updated (at next frame) by the main loop. *)

end (* of Update *)

(* ---------------------------------------------------------------------------- *)


(** {2 Layouts}

    Layouts are rectangular graphical placeholders, in which you should pack all
   your widgets in order to display your GUI. Sophisticated gadgets are usually
   obtained by combining several layouts together.  *)


(** The main, all-purpose graphics container.

 A layout is a "box" (a rectangle) whose purpose is to place onscreen the
   various elements composing the GUI. It can contain a single widget, or a list
   of sub-layouts. In Bogue, we use the housing metaphor: a layout is a {b
   house} that contains either a single {b resident}, or several {b rooms}. Each
   room can be seen as a sub-house, and can contain a resident or
   sub-rooms. Houses and rooms have the type {!t}, while a resident has the type
   {!Widget.t}.

     Technically, the usual metaphor in computer science is a {e Tree}. A layout
   is a tree, each vertex (or node) has any number of branches (or children). A
   leaf (terminal node: without any child) is either empty or contains a
   widget. However, the tree is upside-down (as often): we think of the trunk
   (or {e top-layout}) to be a the top, and the leaves at the bottom.

{5 {{:graph-b_layout.html}Dependency graph}} *)
module Layout : sig
  type t

  exception Fatal_error of (t * string)

  type room_content =
    | Rooms of t list
    | Resident of Widget.t

  (** Not implemented. *)
  type adjust   =
  | Fit
  | Width
  | Height
  | Nothing

  (** {2 Backgrounds} *)

  (** Warning, the [background] type corresponds actually to the {!Style.t}
     type, which means is includes color backgrounds, image patterns, corner and
     shadow styles. *)
  type background

  val color_bg : Draw.color -> background
  (** Construct a background from an RGBA color.*)

  val opaque_bg : Draw.rgb -> background
  (** Construct a background from an RGB (ie non-transparent) color. *)

  val style_bg : Style.t -> background
  (** Construct a background from the given [Style]. *)

  val theme_bg : background
  (** This is the background constructed from the current theme's BG_COLOR. *)

  val set_background : t -> background option -> unit

  val unload_background : t -> unit
  (** Free the texture associated with the background (if any). This can be used
     to force recreating it. *)

  (** {2 Creation of layouts}

      Remark: all layouts have an optional [name] property, which is used only
     for debugging. *)

  val empty : ?name:string -> ?background:background ->
              w:int -> h:int -> unit -> t
  (** An empty layout can reserve some space without stealing focus. *)

  (** {3 Create layouts from widgets} *)

  val resident :
    ?name:string -> ?x:int -> ?y:int -> ?w:int -> ?h:int ->
    ?background:background ->
    ?draggable:bool ->
    ?canvas:Draw.canvas ->
    ?keyboard_focus:bool -> Widget.t -> t
  (** Create a layout (=room) from a single Widget (=resident). The content of
     such a layout cannot be modified. *)

  val flat_of_w :
    ?name:string -> ?sep:int -> ?h:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas -> ?scale_content:bool ->
    Widget.t list -> t
  (** Horizontal arrangement of widgets. See {!flat}. *)

  val tower_of_w :
    ?name:string -> ?sep:int -> ?w:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas -> ?scale_content:bool ->
    Widget.t list -> t
    (** Vertical arrangement of widgets. See {!tower}. *)

  (** {3 Create layouts from other layouts} *)

  val flat :
    ?name:string -> ?sep:int ->
    ?adjust:adjust -> ?hmargin:int -> ?vmargin:int -> ?margins:int ->
    ?align:Draw.align ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> ?scale_content:bool -> t list -> t
  (** Create a horizontal arrangement from a list of rooms. *)

  val tower :
    ?name:string -> ?sep:int ->
    ?margins:int -> ?hmargin:int -> ?vmargin:int ->
    ?align:Draw.align ->
    ?adjust:adjust ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> ?clip:bool -> ?scale_content:bool -> t list -> t
  (** Create a vertical arrangement from a list of rooms. *)

  val superpose :
    ?w:int -> ?h:int -> ?name:string ->
    ?background:background -> ?canvas:Draw.canvas -> ?center:bool ->
    ?scale_content:bool ->
    t list -> t
  (** Create a new layout by superposing a list of layouts without changing
     their (x,y) position. *)

  (** Remark: when creating a house (a layout) with [flat*], [tower*], or
      [superpose], the size of the inner rooms will be automatically updated
      whenever the size of the house is modified. However, as soon as one
      manually sets the size or the position of a room inside this house with
      {!set_width}, {!setx} and likes, then the room will stop reacting to
      changes of the house size. *)

  (** {2 Some useful layout combinations} *)

  val make_clip : ?w:int ->
    ?scrollbar:bool ->
    ?scrollbar_inside:bool -> ?scrollbar_width:int -> h:int -> t -> t
  (** Clip a layout inside a smaller container and make it scrollable, and
      optionally add a scrollbar widget. *)

  (** {2 Get layout attributes} *)

  val xpos : t -> int
  (** get current absolute x position of the layout (relative to the top-left
     corner of the window). Not necessarily up-to-date. *)

  val ypos : t -> int
  (** see {!xpos} *)

  val width : t -> int
  val height : t -> int
  val get_size : t -> int * int
  (** [get_size l] is equivalent to [(width l, height l)] *)

  val get_physical_size : t -> int * int
  (** multiplies [get_size] by the Theme scaling factor. This gives in principle
     the correct size in physical pixels, up to an error of +/- 1pixel, due to
     rounding error. *)

  val getx : t -> int
  (** Compute the relative x position of the room with respect to its house,
     using animations if any. Because of this, this function should not be
      called by the animation itself! Use {!get_oldx} instead.  *)

  val get_oldx : t -> int
  (** Return the last computed value for the relative x position of the
     layout. *)

  val gety : t -> int
  val get_oldy : t -> int

  val widget : t -> Widget.t
  (** Return the resident widget, or
      @raise Not_found if the layout is not a {e leaf}. *)

  val top_house : t -> t
  (** Return the top of the layout tree (the "house" that contains the given
     layout and that is not contained in another layout). It is the only layout
     that is directly attached to a "physical" (SDL) window. *)

  val get_content : t -> room_content

  val get_rooms : t -> t list

  val has_resident : t -> bool

  (** {2 Modify existing layouts}

      Layouts should be modified only by the main Thread. If you want to modify
      a Layout within a {!Widget.connection} without [Main] priority,
      you should use {!Sync.push}, or properly lock it using
      {!lock}/{!unlock}.  *)

  val auto_scale : t -> unit
  (** Set the layout to automatically scale its inner rooms when the layout size
     is modified. *)

  val disable_resize : t -> unit
  (** This makes sure that nothing is executed when someone tries to resize the
      layout. *)

  val on_resize : t -> (unit -> unit) -> unit
  (** [on_resize room f] will execute [f ()] upon resizing the room's house (or
      the room's window, in case the room is the top house, see {!top_house}),
      in addition to the already registered resized functions. Warning: placing
      the room in another layout will likely reset the resize function (unless
      you set the [scale_content] flag to [false], see eg. {!flat} and the
      remark below that). Hence [on_resize] should be called after the room is
      hosted in its house. *)

  val set_width : ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
    -> t -> int -> unit
  (** [set_width] and similar functions will not work if there is an animation
      running acting of the variable we want to set (here, the width). Most of
      these functions will stop the automatic resizing mechanism of the
      room. Use {!auto_scale} to reactivate it. *)

  val set_height :  ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int -> unit
  val set_size :  ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int * int -> unit
  val setx : ?keep_resize:bool -> t -> int -> unit
  val sety : ?keep_resize:bool -> t -> int -> unit
  val set_show : t -> bool -> unit

  val set_shadow : t -> Style.shadow option -> unit

  val fix_content : t -> unit
  (** Disable automatic resizing of the rooms inside this layout. *)

  val fit_content : ?sep:int -> t -> unit
  (** Adapt the size of the layout (and their houses) to the disposition of the
     contained rooms. *)

  val set_rooms : t -> ?sync:bool -> t list -> unit
  (** Modify the layout content by replacing the former content by a new list of
     rooms. Use [sync=true] (the default) as much as possible in order to avoid
     multi-threading problems. Then the changes will be applied by the main
      thread at next frame (see {!Sync}). *)

  val replace_room : by:t -> t -> unit
  (** Replace "room" by "by" inside its "house" in lieu and place of the initial
      room. No size adjustments are made. Of course this is dangerous, because
      it modifies both the house and "by". Beware of circular
      dependencies... Cannot be used for the [top_house] (the window layout)
      because that layout has no house. *)

  val unload_textures : t -> unit
  (** Use this to free the textures stored by the layout (and its children) for
     reducing memory. The layout can still be used without any impact, the
     textures will be recreated on the fly.  *)

  val lock : t -> unit
  val unlock : t -> unit
  (** In general, modifying a layout should by done by the main Thread or by
      using a {!Sync.push}. However, in case you need a layout to be modified by
      different threads, you should lock it with {!lock}. Once a layout is
      locked, another [lock] statement from another thread will wait for the
      previous lock to be removed by {!unlock}. Locking twice by the same thread
      is allowed, and will not block, which allows recursive locking, but this
      practice should be avoided because it is difficult to debug. If you need a
      higher level locking API, wrap the layout in a {!Var.t} variable. *)



  (** {2 Animations}

      Position, size, alpha channel, and rotation of Layouts use [Avar]
     variables and hence can be easily animated. Most predefined animations have
      a default duration of 300ms. *)

  (** {3 Generic animations}

      These functions assign an animated variable if type {!Avar.t} to one
     of the properties of the layout (position, width, etc.)  *)

  val animate_x : t -> int Avar.t -> unit
  (** Assign an Avar to the layout x position. *)

  val animate_y : t -> int Avar.t -> unit
  val stop_pos : t -> unit
  (** Stop animations of the variables x and y. *)

  val animate_w : t -> int Avar.t -> unit
  val animate_h : t -> int Avar.t -> unit
  val animate_alpha : t -> float Avar.t -> unit
  val animate_angle : t -> float Avar.t -> unit

  (** {3 Predefined animations} *)

  val hide : ?duration:int -> ?towards:Avar.direction -> t -> unit
  (** See {!show}. *)

  val show : ?duration:int -> ?from:Avar.direction -> t -> unit
  (** Does nothing if the layout is already fully displayed. Only the
     [Avar.Top] and [Avar.Bottom] directions are currently implemented. For
     these directions, [hide] and [show] do {e not} modify the position
     variables (x,y) of the layout, they use a special variable called
     [voffset]. *)

  val fade_in : ?duration:int -> ?from_alpha:float -> ?to_alpha:float ->
    t -> unit
  (** Animate the alpha channel of the layout. Can be combined with animations
     involving the other animated variables. Does {e not} modify the [show]
     status of the layout. By default, [from_alpha=0.] (transparent) and
      [to_alpha=1.]  (opaque).  *)

  val fade_out : ?duration:int ->
    ?from_alpha:float -> ?to_alpha:float -> ?hide:bool -> t -> unit
  (** See {!fade_in}. WARNING: fading out to alpha=0 results in a completely
     transparent layout, but the layout is {e still there} (it's not
     "hidden"). Which means it can still get mouse focus. If you want to hide
     it, then use [hide=true]. By default, [hide=false], [from_alpha] is the
     current alpha of the layout, and [to_alpha=0.] *)

  val rotate : ?duration:int -> ?from_angle:float -> angle:float -> t -> unit
  (** Rotate all widgets inside the layout around their respective centers. For
      a global rotation, use a {!Snapshot}. *)

  val slide_in : ?duration:int -> ?from:Avar.direction -> ?dst:t -> t -> unit
  val slide_to : ?duration:int -> t -> int * int -> unit
  (** [slide_to room (x0,y0)] will translate the [room] to the position
     [(x0,y0)]. *)

  val follow_mouse : ?dx:int -> ?dy:int ->
    ?modifierx:(int -> int) -> ?modifiery:(int -> int) -> t -> unit
  val oscillate : ?duration:int -> ?frequency:float -> int -> t -> unit
  val zoom : ?duration:int -> from_factor:float -> to_factor:float -> t -> unit

  val reflat : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit
  (** Adjust an existing layout to arrange its rooms in a "flat" fashion, as if
     they were created by {!Layout.flat}. Will be animated if [duration <> 0]. *)

  val retower : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit

  (** {2 Windows}

      An SDL window is created for each Layout in the list sent to
     {!Main.create}.  *)

  val window_opt : t -> Tsdl.Sdl.window option
  (** Return the SDL window containing the layout. It will return [None] if the
     window was not created yet, or was previously destroyed. Note that SDL
     windows are created by {!Main.run}, not before. *)

  val show_window : t -> unit
  (** Make the window containing the layout appear onscreen, using [set_show]
     and [Sdl.show_window]. (If the layout was hidden at startup,
     [Sdl.show_window] is not enough to display the layout: use this function
     instead.) *)

  val hide_window : t -> unit
  (** Hide the window containing the layout. *)

  val set_window_pos : t -> int * int -> unit
  (** [set_window_pos layout x y] sets the position of the window containing
     [layout] to (x,y), in physical pixels. (0,0) is top-left. This should be
     run {b after} {!Main.create}.  *)

  val get_window_pos : t -> int option * int option
  (** Return the window position within the desktop, in physical pixels. *)

  val push_close : t -> unit
  (** Emit the close-window event to the window containing the layout, as if the
     user clicked on the close button. This should close the window at the next
     graphics frame, or execute the function registered by
     {!Window.on_close}. *)

  val destroy_window : t -> unit
  (** Emit the destroy_window event to ask Bogue to destroy the SDL window
      containing the layout. *)

  (** {2 Misc} *)

  val claim_keyboard_focus : t -> unit

  val set_cursor : t option -> unit
  (** Set the current cursor to the default value for this layout. *)

  (** Search for the room containing the widget, if any. *)
  val containing_widget : Widget.t -> t option

end (* of Layout *)

(* ---------------------------------------------------------------------------- *)

(** Adjust various spacing and sizes of layouts.

These functions {e do not take effect immediately!} They will be executed, in
   the order of their invocation, at the next graphics frame (or at startup if
   they are invoked before the start of the mainloop).

{5 {{:graph-b_space.html}Dependency graph}}
 *)
module Space : sig

  val hfill : ?right_margin:int -> unit -> Layout.t
      (** When used in a {!Layout.flat} structure, this special empty layout will
     automatically expand in order to fill the available width in the parent
     house. The other inhabitants keep the width they had at the execution of
     the [hfill] invocation. Their height is resized as usual. Only one [hfill]
     layout should be used in a given house. *)


  val make_hfill : ?right_margin:int -> Layout.t -> unit
  val full_width : ?right_margin:int -> ?left_margin:int -> Layout.t -> unit
     (** This will set the width of the room (layout) in order to occupy the whole
     width of its house. *)

  val make_vfill : ?bottom_margin:int -> Layout.t -> unit
 (** Like {!hfill}, but applies to the specified layout instead of creating an
      empty one. *)

  val vfill : ?bottom_margin:int -> unit -> Layout.t
    (** When used in a {!Layout.tower} structure, this special empty layout will
     automatically expand in order to fill the available height in the parent
     house. See {!hfill}. *)

  val full_height : ?top_margin:int -> ?bottom_margin:int -> Layout.t -> unit

  val keep_bottom : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit

  val keep_right : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit


end (* of Space *)

(* ---------------------------------------------------------------------------- *)

(** Convert Bogue objects to strings for debugging.

{5 {{:graph-b_print.html}Dependency graph}}
*)
module Print : sig

  val layout_down : ?indent:string -> Layout.t -> string
  (** Print a layout with all its rooms and subrooms (children). *)

  val layout_up : ?indent:string -> Layout.t -> string
  (** Print the layout node and all the rooms (houses, or parents) in which it
      is contained. *)

  val layout_error : Layout.t -> string -> unit
  (** Print a message to stderr and dump the top_house structure to a temporary
     file. *)

end (* of Print *)

(* ---------------------------------------------------------------------------- *)

(** Create an image from a Layout.

{5 {{:graph-b_snapshot.html}Dependency graph}}
*)
module Snapshot : sig

  val create : ?border:Style.border -> Layout.t -> Widget.t
  (** Should be called from the main thread only. There are some issues with
     transparency.
     @return a Box widget. *)

end (* of Snapshot *)

(* ---------------------------------------------------------------------------- *)

(** Handle large lists by not displaying all elements at once.

Very quickly, displaying a list of layouts (for instance, listing files in a
   directory) can run the computer out of memory if it tries to keep in memory
   the textures of {b all} entries of the list. In these cases you need to use a
   [Long_list].

See for instance the example 34: `boguex 34` that displays a list of 1 million
   entries.

Long_lists may contain any type of Layout. They don't need to be all of the same
   dimension. Instead of providing the list of layouts, one must give a function
   [generate] such that the layout given by [generate i] is the i-eth element of
   the list.

{5 {{:graph-b_long_list.html}Dependency graph}} *)
module Long_list : sig
  type t

  val create : w:int -> h:int -> length:int ->
    ?first:int ->
    generate:(int -> Layout.t) ->
    ?height_fn:(int -> int option) ->
    ?cleanup:(Layout.t -> unit) ->
    ?max_memory:int ->
    ?linear:bool -> ?scrollbar_width:int -> unit -> Layout.t
  (** Create a long list through the function [generate] which maps any index
     {e i} to the {e ieth} element (layout) of the list. If specified (which is
     not a good idea), the [max_memory] should be at least twice the area (in
     physical pixels) of the visible part of the list. If the number of elements
     is large (typically 100000 or more, this depends on your CPU), its is
     highly advisable to provide a [height_fn], which to an index {e i} gives
     the height (in logical pixels) of the {e ieth} entry. If some heights are
     not known in advance, it's ok to return [None]. For instance, if all
     entries have the same height, say 30 pixels, one can define

      {[ let height_fn _ = Some 30 ]} *)

end (* of Long_list *)

(* ---------------------------------------------------------------------------- *)

(** Switch between layouts using Tabs.

{5 {{:graph-b_tabs.html}Dependency graph}}
*)
module Tabs : sig

  val create :
    ?slide:Avar.direction ->
    ?adjust:Layout.adjust -> ?expand:bool ->
    ?canvas:Draw.canvas ->
    ?name:string -> (string * Layout.t) list -> Layout.t
end (* of Tabs *)

(* ---------------------------------------------------------------------------- *)

(** Put layouts on top of others.

{e Warning:} For all functions in this module, the destination layout must be a
   house, not a single resident.

{5 {{:graph-b_popup.html}Dependency graph}} *)
module Popup : sig

  val add_screen : ?color:Draw.color -> Layout.t -> Layout.t
  (** Add a screen on top of the layout. This can be useful to make the whole
      layout clickable as a whole.
      @return the screen. *)

  (** Generic modal type popup *)
  val attach : ?bg:Draw.color ->
    ?show:bool -> Layout.t -> Layout.t -> Layout.t
  (** [attach house layout] adds two layers on top of the house: one for the
     screen to hide the house, one for the layout on top of the screen.
     @return the screen. *)

  val info : ?w:int -> ?h:int -> ?button_w:int -> ?button_h:int ->
    ?button:string -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with a text and a close button. By
      default, [button="Close"]. Use the optional parameters [w,h] to impose the
      size of the button. *)

  val yesno : ?w:int -> ?h:int -> ?button_w:int -> ?button_h:int ->
    ?yes:string -> ?no:string ->
    yes_action:(unit -> unit) ->
    no_action:(unit -> unit) -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with two yes/no buttons. By default,
      [yes="Yes"] and [no="No"]. Use the optional parameters [w,h] to impose the
      common size of the two buttons. *)

  val one_button : ?w:int -> ?h:int -> ?on_close:(unit -> unit) ->
    button:string -> dst:Layout.t -> Layout.t -> unit
  (** Here the optional parameters [w] and [h] set the width and height of the
      button.*)

  val two_buttons : ?w:int -> ?h:int -> label1:string -> label2:string ->
    action1:(unit -> unit) -> action2:(unit -> unit) ->
    content:Layout.t -> Layout.t -> unit

  type position =
  | LeftOf
  | RightOf
  | Above
  | Below
  | Mouse

  val tooltip : ?background:Layout.background ->
    ?position:position ->
    string -> target:Layout.t -> Widget.t -> Layout.t -> unit
  (** [tooltip text ~target widget layout] adds a tooltip which will appear on
     [layout], next to [target] (which should be a sublayout of [layout]), when
     the [widget] gets mouse focus and mouse is idle for some time on it. A
     tooltip it not a modal popup, it does not prevent from interacting with the
     rest of the layout. *)

end (* of Popup *)

(* ---------------------------------------------------------------------------- *)

(** Various types of menus.

The generic {!create} function produces menus whose entries can be arbitrary
   layouts located at arbitrary places. But for usual entries, it is enough to
   provide a string for the entry label, and the layout will be constructed
   automatically.

The specialized {!bar} function will produce a familiar menu bar with drop-down
   submenus.

{5 {{:graph-b_menu.html}Dependency graph}}
*)
module Menu : sig

  type t
  (* The type of generic menus. *)

  type action = unit -> unit

  type label =
    | Text of string
    | Layout of Layout.t

  type entry = {
      label : label;
      content : content }

  and content =
    | Action of action
    | Flat of entry list
    (** A Flat content will produce a horizontal menu *)
    | Tower of entry list
    (** A Tower content will produce a vertical menu *)
    | Custom of entry list
    (** In a Custom content, only Layout labels should be used, and their
       position should be defined before creating the menu. *)
    | Separator
    (** Currently only used for inserting separator lines in Tower menus. *)

  val create : ?dst:Layout.t -> content -> t
(** Generic menu creation, inserted in the [dst] layout. *)

  val add_bar : dst:Layout.t -> entry list -> unit
  (** Creation of a menu bar in the [dst] layout, with drop-down submenus.
      [bar dst entries] inserts a layout which contains the menu bar into the top of
      the [dst] layout (so, some room should be provided). The [dst] layout
      should be big enough to contain the submenus. Any item flowing out of [dst]
      will not get focus. *)

  val bar : entry list -> Layout.t
  (** Return a menu layout that will be installed with {!add_bar} into the top
     house at startup. *)

  val separator : entry

end

(* ---------------------------------------------------------------------------- *)

(** Drop-down select list.

It's the usual select box which opens a drop-down list when clicked on, similar
   to the [<select>] html tag.

 Under the hood, a select list is a special type of menu with a single entry
   having a submenu.

{5 {{:graph-b_select.html}Dependency graph}} *)
module Select : sig

  val create : ?dst:Layout.t ->
    ?name:string ->
    ?action:(int -> unit) ->
    ?fg:Draw.color ->
      string array -> int -> Layout.t
  (** [create string_array i] creates a select box with preselected entry
     [i]. For instance [create [| "A"; "B"; "C" |] 1] will create a select box
     with default choice ["B"]. The [action] (if specified) is executed when an
     item is selected, and takes as argument the index of the selected item.

        @return a layout showing the selected item. *)

end (* of Select *)

(* ---------------------------------------------------------------------------- *)

(** Check list with a single choice.

    Each item of the list is displayed with a 'radio button' in front of it, and
   at most one item can be selected, similarly to [<input type="radio"...>] in
   html. Radiobuttons are implemented with {!Check.t}.

{5 {{:graph-b_radiolist.html}Dependency graph}}
*)
module Radiolist : sig
  type t

  val vertical : ?name:string -> ?click_on_label:bool -> ?selected:int -> string array -> t
  (** A radiolist with the usual vertical layout of items. The option [click_on_label] is true be default: one can click on the label to select it. *)

  val of_widgets : ?selected:int -> Widget.t list -> t

  val layout : t -> Layout.t
  (** The layout to display the radiolist. *)

  val get_index : t -> int option
  val set_index : t -> int option -> unit
  (** Set the selected entry to the specified index and directly activate the
     button's connections with the {!Trigger.var_changed} event. *)

  val active_widgets : t -> Widget.t list
  (** @return the list of widgets that are active for selecting entries ({e
     i.e.} either radiobuttons or radiobuttons and labels, depending on
     [click_on_label]. *)
end (* of Radiolist *)

(* ---------------------------------------------------------------------------- *)

(** Tables with sortable columns and selectable rows.

{5 {{:graph-b_table.html}Dependency graph}}
*)
module Table : sig
  type column =
    { title : string;
      length : int;
      rows : int -> Layout.t;
      compare : (int -> int -> int) option;
      (* use "compare i1 i2" in order to compare entries i1 and i2 *)
      width : int option;
    }
  type t

  val create : ?w:int -> h:int -> ?row_height:int ->
    ?name:string ->
    column list -> Layout.t * (Selection.t, Selection.t) Tvar.t
  (** @return a layout and a Tvar. The Tvar can be used to see which rows were
      selected by the user, and also to modify the selection if needed. *)

  val of_array : ?w:int ->
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string ->
    string list ->
    string array array -> Layout.t * (Selection.t, Selection.t) Tvar.t

  val of_list :
    ?w:int ->
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string ->
    string list list -> Layout.t * (Selection.t, Selection.t) Tvar.t

end (* of Table *)

(* ---------------------------------------------------------------------------- *)

(** {2 Windows}

    In order to display a Layout, Bogue needs to create a {!Window.t} for it,
    and pass it as argument of {!Main.create}. This is done automatically if you
    use {!Main.of_layouts}, so most of the time you don't need to deal with
    {!Window.t}'s.

    Windows are created by SDL, and hence will appear with the usual decorations
    of your Desktop Environment.  *)
module Window : sig
  type t
  val create : ?on_close:(t -> unit) -> Layout.t -> t
  (** Create a window from the given layout. The layout must not belong to any
     room. If the layout is hidden, the window will be created but not shown.
     @param on_close Set the function to be executed when the user wants to
     close the window. By default, the window will be destroyed. Hence, setting
     a function can prevent the window from being closed. However, if this is
     the sole open window, clicking on the close button will also emit the
     'Quit' event, and will terminate Bogue anyways. *)

  val on_close : t -> (t -> unit) option -> unit
  (** Modify the on_close parameter of {!create}. *)

  val destroy : t -> unit
  (** Ask Bogue to destroy the window. *)

  val set_size : w:int -> h:int -> t -> unit
  (** Set window size in physical pixels. Only works after the window is
     physically created by {!Main.run}. However, you may use [set_size] in
     advance with {!Sync.push}. *)

  val maximize_width : t -> unit
  (** See remarks in {!set_size}. *)

  end

(* ---------------------------------------------------------------------------- *)

(** {2 The Bogue mainloop}

Because a GUI continuously waits for user interaction, everything has to run
   inside a loop. You start the loop with {!run}, and this is usually the last
   command of your Bogue code.  *)

(** Control the workflow of the GUI mainloop.

{5 {{:graph-b_main.html}Dependency graph}}
*)
module Main : sig
  type board
  (** The board is the whole universe of your GUI. It contains everything. *)

  type shortcuts

  exception Exit
  (** Raising the [Exit] exception will tell the GUI loop to terminate. *)

  val exit_on_escape : int * int * (board -> unit)
  (** If the [exit_on_escape] shortcut is given to the {!make} function, then
     the {!Exit} exception will be raised upon pressing the Escape key. *)

  val create : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Window.t list -> board
  (** Create a [board] from a list of layouts and connections. The list of
     connections can be empty, because connections can be added afterwards. Each
     Layout in the list will open as a new window.

      @param shortcuts This optional argument is a {%html:<a href="#shortcuts">shortcut map</a>%}.

      @param on_user_event This optional argument is a function to be executed
     (by the main thread) when a {!Trigger.user_event} is emitted.

*)

  val get_monitor_refresh_rate: board -> int option
  (** [get_monitor_refresh_rate board] returns the monitor refresh rate,
    for the monitor containing [board].
  *)

  val of_windows :  ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Window.t list -> board
  (** Synonym for {!create}. *)

  val of_layouts : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Layout.t list -> board
  (** Similar to {!create}. Each layout in the list will be displayed in a
     different window. *)

  val of_layout : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Layout.t -> board
  (** Similar to {!of_layout} but with only one layout. *)

  val make : ?shortcuts:shortcuts ->
    (Widget.connection list) -> Layout.t list -> board
  (** Similar to {!of_layouts}.

     @deprecated   (since 20220418). Use {!of_layouts} or {!create} instead. *)

  val run :
    ?vsync:bool ->
    ?before_display:(unit -> unit) ->
    ?after_display:(unit -> unit) -> board -> unit
  (** This is finally how you run your app! It creates the SDL windows
     associated with the {!Window.t}s registered with the board, and launches
     the main loop. This function only returns when all windows are closed (in
     case at least one window was created), or when the {!Exit} exception is
     raised.
    [vsync] defaults to [true] and enables synchronization to monitor refresh rate
    where possible, otherwise a 60 FPS {!Time.adaptive_fps} is used.
    *)

  (** {3:shortcuts Creating global keyboard shortcuts} *)

  type shortcut_action = board -> unit

  val shortcuts_empty : unit -> shortcuts

  val shortcuts_add : shortcuts ->
    ?keymod:Tsdl.Sdl.keymod -> int -> shortcut_action -> shortcuts

  val shortcuts_add_ctrl : shortcuts -> int -> shortcut_action -> shortcuts

  val shortcuts_add_ctrl_shift : shortcuts ->
    int -> shortcut_action -> shortcuts

  val shortcuts_of_list : (int * int * shortcut_action) list -> shortcuts
  (** Construct shortcuts from a list of (SDL keycode, SDL keymod, action). *)

  (** {2 Using Bogue together with another graphics loop}

      See the [embed] example. *)

  val make_sdl_windows : ?windows:Tsdl.Sdl.window list -> board -> unit
  (** This is only useful if you have your own graphics loop, and do {e not} use
     {!run}. This function creates an SDL window for each top layout in the
     board. One can use predefined windows with the optional argument
     [windows]. They will be used by the layouts in the order they appear in the
     list. If there are fewer windows than layouts, new windows are created. If
      there are more, the excess is disregarded. *)

  val refresh_custom_windows : board -> unit
  (** Ask the GUI to refresh (ie. repaint) the custom windows (those that were
     not created by Bogue itself). *)

  val one_step : ?before_display:(unit -> unit) ->
    bool -> (unit -> unit) * (unit -> unit) -> ?clear:bool -> board -> bool
(** This is only useful if you have your own graphics loop, and do {e not} use
   {!run}. Calling [one_step ~before_display anim (start_fps, fps) ~clear board]
   is what is executed at each step of the Bogue mainloop. If [anim=true] this
   step is {e non blocking}; this is what you want if either Bogue or your loop
   has an animation running. If [anim=false] then the function will wait until
   an event is received.
   @return [true] if the GUI currently handles an animation. In this case
   [fps()] was executed by [one_step]. If not, you should handle the frame rate
   yourself. *)

  val get_frame : unit -> int
  (** Number of displayed frames since startup. *)

  val quit : unit -> unit
  (** Use this to close SDL windows and cleanup memory, after {!run} has
     returned. This does not exit your program. Calling [quit ()] is not
     necessary if your program exits after {!run}.*)

end (* of Main *)

(* ---------------------------------------------------------------------------- *)

(** Alias for {!Main} *)
module Bogue = Main

(* ---------------------------------------------------------------------------- *)

(** {2:example Example}

    Here is a minimal example with a label and a check box.

{[
open Bogue
module W = Widget
module L = Layout

let main () =

  let b = W.check_box () in
  let l = W.label "Hello world" in
  let layout = L.flat_of_w [b;l] in

  let board = Bogue.of_layout layout in
  Bogue.run board;;

let () = main ();
  Bogue.quit ()
]}

This can be compiled to bytecode with

{v
ocamlfind ocamlc -package bogue -linkpkg -o minimal -thread minimal.ml
v}

and to native code with

{v
ocamlfind ocamlopt -package bogue -linkpkg -o minimal -thread minimal.ml
v}

Then execute the compiled code:

{v
./minimal
v}

A window should open which should look like this:

{%html:<div class="figure"><img src="minimal.png"></div>%}

You may also evaluate this code in a Toplevel! (for instance [utop], or in an [emacs] session...). Just insert

{v
#thread;;
#require "bogue";;
v}

at the top, then paste the example code above, and add [;;] at the end.

  *)
