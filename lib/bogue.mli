(* !!!!!!!!! autogenerated, don't edit !!!!!!!!! *)



(*---
  Copyright: see LICENCE

  Note to devs: this interface file exposes only a small proportion of usable
  Bogue functions. The idea is to publicly expose only those that are robust
  enough and well tested.

  However, for development, this is not a restriction, because the other
  individual modules do not have any interface. If we find ourselves
  consistently using some function, then it's a good idea to think about
  including it here.

  ---*)

(** General purpose GUI (Graphical user interface) library for Ocaml.

   Bogue is a lightweight and fast GUI for developing desktop applications,
   games, or for easy debugging of non-GUI programs.

   Bogue is entirely written in {{:https://ocaml.org/}ocaml} except for the
   hardware accelerated graphics library {{:https://www.libsdl.org/}SDL2}.

@version 20260226

@author Vu Ngoc San

@see <https://github.com/sanette/bogue> the source code on github

*)

(**
 {e This documentation is best viewed on
 {{:https://sanette.github.io/bogue/Bogue.html}this page}. (While on
 {{:https://ocaml.org/p/bogue/latest/doc/Bogue/index.html}ocaml.org} some links
 may be broken.)}
*)

(** {3 Quick start}

 For a quick start, see Bogue's {{:Principles.html}general principles}, the
 minimal {{!example}example}, and the
 {{:https://sanette.github.io/bogue-tutorials/bogue-tutorials/index.html}tutorials}. {e
 (Again, if the links don't work, make sure you are viewing this page from
 {{:http://sanette.github.io/bogue/Bogue.html}here}.)}


    The main modules are

    - {!Main} (creating, running, and quitting your app),
    - {!Layout} (arranging widgets to form sophisticated interfaces like table,
    menus, etc.) and
    - {!Widget} (the building blocks, like labels, buttons, etc.).

   {!indexlist}


*)

(* ---------------------------------------------------------------------------- *)

(** {1 List of Modules}

    The only thing that [open Bogue] does is to bring these modules into your
    namespace. They have quite common names, so beware of conflict. In case of
    doubt, don't open [Bogue], and access the modules by using the [Bogue]
    prefix, for instance [Bogue.Widget.label]. The {!Widget} and {!Layout}
    modules are probably the ones that you will find yourself using the most, so
    it's a good idea to alias them:

{[module W = Bogue.Widget
module L = Bogue.Layout]}


{%html:<br><br>%}

*)



(** Theme variables.

    A number of variables control the appearance of your Bogue application. They
    are called {%html:<a href="#list">Theme variables</a>%}.  They take effect
    when you start your application up (no need to recompile).  For quick
    experimentation, they can be modified as environment variables, for instance
    in a terminal: {v export BOGUE_SCALE=2.5 v} They can also be saved in
    configuration files, and you may organize as many config files as you want
    into {e themes}.

{3:config Where are the config files?}

    The config files are all called [bogue.conf]. Several locations are used.
    Upon installing Bogue, a system wide Bogue share directory is created. If
    you used an {b opam} install, this will be {v $(opam var share)/bogue v} The
    share directory contains a [themes] directory, which itself contains a
    [default] dir.  This is where the default configuration file resides.

    However, {b if you want to modify the themes}, it is advisable to create
    your own Bogue share dir.  This personal Bogue dir should be
    [$(XDG_CONFIG_HOME)/bogue].  (If [$XDG_CONFIG_HOME] is not defined in your
    system, you may use [$HOME/.config/bogue]).  So, this is what you can do for
    creating your personal Bogue dir for the first time:
    {v cp -r $(opam var share)/bogue $HOME/.config/bogue v}

    - Each theme has its own directory inside the [themes] directory (inside the
    Bogue [share] dir), in which there is a [bogue.conf] file where the Theme
    variables are defined.

    - A global user config file [$HOME/.config/bogue/bogue.conf] overrides the
    theme files.

    - A [bogue.conf] file in the same directory as the executable overrides the
    other config files.

    - The syntax of the config file is [VARIABLE = value], one entry per line.
    Notice the spaces surrounding [=]. Comment lines starting by [#] are
    ignored.  For instance:
{v
## BOGUE version 20220115
THEME = dark
BACKGROUND = color:azure
v}
    The first line <code>## BOGUE version XXX</code> is compulsory.

{3:list Here is the list of Theme variables:}

- [BACKGROUND]: the default background for all windows. It can be a color
  (eg. [color:darkturquoise] or [color:#00CED1]), or an image file
  (eg. [file:myimage.png]). See {%html:<a href="#path">below</a>%}
  for how to specify paths.
- [BG_COLOR]: a background color (eg. [darkturquoise], or [#00CED1])
  that is used by default by some widgets/layouts.
  It should be clearly visible over the [BACKGROUND].
- [BUTTON_COLOR_ON]: the color of active buttons.
- [BUTTON_COLOR_OFF]: the color of inactive buttons.
- [CHECK_ON]: the image used for the 'checked' icon. It can be a file
  (eg. [myimage.png]) or a font-awesome icon (eg. [fa:check-square-o]).
- [CHECK_OFF]: the image used for the 'unchecked' icon. See [CHECK_ON].
- [CURSOR_COLOR]
- [DIR]: the directory containing the themes subdirectories.
    Default: auto-detected at startup, usually [$HOME/.config/bogue/themes]
- [DISABLED_BG]: background color indicating a disabled area.
- [DISABLED_FG]: color for disabled texts.
- [FA_DIR]: the fontawesome directory inside [DIR/common/].
- [FAINT_COLOR]: a non-obtrusive color for disabled options or
  text of little importance.
- [LABEL_COLOR]: the color for text or icon labels.
- [LABEL_FONT]: path of a TTF font for text labels.
  If your system has [fontconfig], any installed font (as listed by [fc-list])
  can be specified without the full path. Eg: [Ubuntu-R.ttf].
- [LABEL_FONT_SIZE]: integer, eg [14].
- [LOG_TO_FILE]: if "false", all log messages will appear on the console.
  If "true", the messages are instead sent to a log file, typically in the
  "/tmp" directory. Log files can be viewed on an ANSI terminal with
  [less -R] or with emacs using xterm-color-colorize-buffer
  (from the xterm-color package).
- [MENU_HL_COLOR]: the color for highlighting selected menu entries.
- [MENU_BG_COLOR]
- [MONO_FONT]: monospace font. See [LABEL_FONT].
- [NATURAL_SCROLLING]: "true", "false", or "auto" (default): Control the
  direction of vertical scrolling with the mouse wheel or the touchpad. If set
  to "auto", scrolling will be "natural" on Mac OS, and reversed everywhere
    else.
- [NO_VSYNC]: By default, Bogue tries to enable (Adaptive) VSync. Setting this
    variable to "true" disables this, and then, instead, we try to detect the
    monitors refresh rates.
- [OPENGL_MULTISAMPLE]: set this to "true" to enable this opengl attribute.
- [ROOM_MARGIN]
- [SCALE]: global scale (any non-negative float). For instance if [SCALE = 2.],
  all dimensions given to Bogue functions will be multiplied by 2 before
  rendering to obtain
  the hardware size in pixels.
  If set to [0.] or not specified, it is autodetected to match your screen DPI
  (using [xdpyinfo], if present).
- [INT_SCALE]: set this to "true" to force integer scale when using auto-detection.
  Some games may require this to avoid small graphics artifacts.
- [SEL_BG_COLOR]: background color for selected items in lists.
- [SEL_FG_COLOR]: text color for selected items in lists.
- [SMALL_FONT_SIZE]: integer. Used for instance for tooltips popups.
- [TEXT_COLOR]: color of standard text displays.
- [TEXT_FONT]: used for text displays. See [LABEL_FONT].
- [TEXT_FONT_SIZE]
- [THEME]: the name of the theme to use.
  It should be the name of the directory within the [themes] dir.
  As soon as this variable is set, all variables from that theme
  are loaded and override previously defined variables.
  If not specified, the default theme is initially loaded.
- [USE_FSWATCH]: (default="true") Use the external program "fswatch" (if
  available) for file monitoring. If set to "false", (or if "fswatch" is not
   available) we use [Unix.stat]. *

All variables with "COLOR" in their name can be specified either with RGB
hexadecimal like "#00CED1", or with a standard html name like" darkturquoise",
see {{:https://www.rapidtables.com/web/color/html-color-codes.html}this color
table}.

All variables can be overridden by setting the corresponding
environment variables, prepending "BOGUE_". For instance:
{v
export BOGUE_LABEL_COLOR=forestgreen
v}

{%HTML:<br>%}


{2:path How to load assets (images, sounds, etc.)}

When specifying a file to load, for instance
{v
BACKGROUND = file:background.png
v}
you need to specify where the file should be searched. Here are the rules:

+ If the file string starts with [/], it should be an absolute path
  (eg. [file:/home/alice/myimage.png]), no additional search is performed.
+ If the file string starts with [%], for instance
  [file:%assets/images/bob.png], then the [%] char is replaced by the Bogue dir,
  for instance [file:/home/bob/.config/bogue/assets/images/bob.png].
+ Otherwise, the file is first searched in the directory where your application
  binary resides (if any), then in the current directory, then in the current
  theme's directory (for instance [$HOME/.config/bogue/themes/default]), and
    finally in the special "common" theme.


{5 {{:graph-dot-b_theme.html}Dependency graph}} *)
module Theme : sig

  (** {2 Accessing Theme variables}

      Theme variables are essentially for Bogue's internal use, but sometimes it
      can be useful to access or modify their values. See above for their
      description.

      {b Warning:} Theme variables are global variables and should be modified
      (by the main thread) {e before} starting the main loop (with {!Main.run})
      if you want predictable results. *)

  val room_margin : int

  val scale_int : int -> int
  (** Conversion: Bogue dimension -> hardware pixel dimension. The latter is
      obtained by multiplying by [SCALE].

      {b Warning:} Bogue scale is detected only when opening a window, typically
      when running {!Main.run}, or manually with {!Draw.video_init}. If you use
      [scale_int] too early you might end up with zeros... If you don't require
      auto-detection, you can use {!set_scale}. *)

  val set_text_font : string -> unit
  val set_label_font : string -> unit
  val set_scale : float -> unit

  val set_int_scale : bool -> unit
    (** Set [INT_SCALE].  *)

  (**/**)
  val set_integer_scale : bool -> unit
  (**/**)

  (** {2 Accessing files installed along with your application}

      Files distributed with your application built with Bogue should be
      installed in a "share" directory, for instance using the [install] stanza
      of [dune] with [(section share)].

      Another solution is to embed your files with the main binary using
      {{:https://github.com/johnwhitington/ppx_blob}ppx_blob}. *)

  val find_share : string -> string -> string option
  (** [find_share app file] returns a guessed location for your application
      share directory (if it exists), for instance
      [/usr/local/share/my_app]. The [app] string should be the system name of
      your application (for instance [app="my_app"]). The returned location is
      guaranteed to contain the given [file]. If you don't have any file to
      search, you may use [file="."].

      {b Warning:} The directory returned by [find_share] is not necessarily
      writable. If you want a directory where the users of your application can
      save their preferences, you should rather use [Sdl.get_pref_path]. *)

  val get_path : ?path:string list -> string -> string
(** [get_path file] returns an absolute path for accessing the given [file]
    using the rules described {%html:<a href="#path">above</a>%}, except if the
    [file] is not found, in which case the string [file] is returned unchanged,
    with the hope that it corresponds to a file in the current
    directory. Instead of the Bogue share directories, alternative directories
    for searching the file can be provided via the [path] option. *)

  val get_font_path_opt : string -> string option
  (** [get_font_path file] returns an absolute path for the given TTF [file], if
      found. If [file] starts with "/", only this location is
      checked. Otherwise, the font file is searched first in the theme
      directory, then in Bogue's common fonts dir, then in the system's fonts
      (using [fc-list], if available). *)

end (* of Theme *)

(* ---------------------------------------------------------------------------- *)

(** Internationalization.

    This module provide ways to automatically translate strings into the user's
    language. The translations are grouped by contexts (predefined contexts
    correspond to Bogue's modules); this allows different translations for the
    same English word, depending on the context. If a translation is not found
    in the current context, all contexts will be examined.

    Example for a one-time translation of the string "save as" in the [File] context:
    {[
module I = I18n.File
print_endline (I.gettext "save as")
]}

    Example for declaring a cached translated variable [s] to be re-used several times:
    {[
module I = I18n.File
let s = I.tt "save as" in
print_endline (I.tf s)
...]}


     {%html:<div class="figure"><img src="images/file_dialog_zh.png"><br> A file dialog with Chinese localization. We used the configuration variables <pre>LANGUAGE=zh BOGUE_LABEL_FONT="/usr/share/fonts/opentype/noto/NotoSerifCJK-Regular.ttc"</pre></div>%}
*)
module I18n : sig

  type locale = { language : string; country : string option }

  val get_locales : unit -> locale list
  (** Return the list of preferred locales as detected from the user's OS. *)

  (** Functions available in every context. *)
  module type ContextInit = sig
    val gettext : string -> string
    (** [gettext text] tries to return the translation of the [text] string into
        the user's preferred language, in the current context. This will load
        the corresponding "locales" files, when available. If the translation is
        not found, other contexts will be examined. If everything fails, the
        original [text] string is returned. *)

    val gettext_opt : string -> string option
    (** Similar to {{!gettext}[gettext]} but returns [None] if the translation
        cannot be found. *)

    val tt : string -> string Lazy.t
    (** Lazy version of {{!gettext}[gettext]}. This is preferred over [gettext]
        if the string is used several times, because the translation is
        cached.

        [tt] means "translate text". *)

    val tf : 'a Lazy.t -> 'a
    (** Shorthand for [Lazy.force]. Example:
        {[
let translated = tt "Hello" in
for _ = 1 to 10 do print_endline (tf translated)]}

        [tf] means "translation force"
    *)

    (** {2 Translating [printf] formats}

        Sometimes the translation of a format string like
        ["%u dollars off coupon"]
        imposes to change the location of the special flags, as in
        ["bon de réduction de %u dollars"].

        Therefore it's easier to translate the whole format string instead of
        working word by word. The [I18n] module provides facilities for
        this. *)

    val t_uint : string -> (int -> string) Lazy.t
    (** For instance:
        {[
let f = t_uint "%u dollars off coupon" in
print_endline ((tf f) 150)]}
        will print, for French locale:
        {[
"bon de réduction de 150 dollars"]}
        as soon as the French translation of  ["%u dollars off coupon"] is declared to be
        ["bon de réduction de %u dollars"]. See {!translate}.
    *)

    val t_int : string -> (int -> string) Lazy.t
    (** Same as {{!t_uint}[t_uint]} but for usual (signed) integers (flag [%i]). *)

    val t_str : string -> (string -> string) Lazy.t
    (** Same as {{!t_uint}[t_uint]} but for strings (flag [%s]). *)

    val t_uint2 : string -> (int -> int -> string) Lazy.t
    (** Similar to {{!t_uint}[t_uint]} but the format string should contain two
        [%s] flags. *)

    (** {2:translate Declaring new translations}

    Translations can be added either programmatically using
    {{!add_translation}[add_translation]} or by directly editing the
    configurations files. *)

    val add_translation : locale -> string -> string -> unit
        (** [add_translation locale text translation] will declare the string
            [translation] to be the translation of the string [text] within the
            current context and for the given [locale]. This will overwrite
            previously defined translations for [text].

            This function does not modify the translation files. See
            {!save_locale}.*)
  end

  val make_context : string -> (module ContextInit)
  (** Create a new module for using the given context. New translations aliases
      can be added by extending the module, as follows:

      {[module My_context = struct
  include (val (make_context "my_context") : ContextInit)
  let hello = tt "Hello"
end]}

  *)

  (** {2 Translation files}

      Translation files are located in the [locales] directory of Bogue's
      [share] directory. See {%html:<a href="Bogue.Theme.html#config">Where are
      the config files?</a>%}.  They are called "[locale_ll_CC.conf]" where [ll]
      is the language code and [CC] the country code, for instance
      "[locale_fr_FR.conf]". They can also be called simply "[locale_ll.conf]"
      for translations which follow the language's main dialect.

      We don't use the traditional ".po" syntax: for simplicity, the syntax of
      the translation files is the one of Bogue's configuration files: each
      translation is written on a new line of the form

  {v English text = Translated text v}

      for instance {v Save as = Enregistrer sous v} The strings (English and
      translated) should not contain any equal ('=') char.  There is a special
      syntax for contexts: the line

      {v __CONTEXT = Context name v}

      indicates that the following translations should apply to the context
      called "Context name", up until a new [__CONTEXT] line.
*)

   val save_locale : ?domain:string -> locale -> unit
  (** Save the translation file for the given locale (including all contexts,
      and all user additions made with [add_translation]). The file is saved in
      the [domain] (= application) directory, which must be found under a
      "share" directory, as given by the function
      {!Theme.find_share}[ domain "."].
      If this dir is not found, the locale is saved in the current
      directory. *)

  (** {2 List of predefined contexts} *)


  module File : sig
    include ContextInit
    (* Recopier les définitions dans b_i18n.ml et modifier avec cherche-remplace:
       let → val
       = tt .* → : string Lazy.t
       = t_uint .* → : (int -> string) Lazy.t
       = t_uint2 .* → : (int -> int -> string) Lazy.t
    *)
    val cancel : string Lazy.t
    val close : string Lazy.t
    val continue : string Lazy.t
    val enter_path : string Lazy.t
    val modified : string Lazy.t
    val name : string Lazy.t
    val no_selection : string Lazy.t
    val one_dir_selected : string Lazy.t
    val one_file_selected : string Lazy.t
    val open_ : string Lazy.t
    val open_dir : string Lazy.t
    val save : string Lazy.t
    val save_as : string Lazy.t
    val select : string Lazy.t
    val select_directory : string Lazy.t
    val select_dirs : string Lazy.t
    val select_file : string Lazy.t
    val select_files : string Lazy.t
    val size : string Lazy.t
    val x_dirs_selected : (int -> string) Lazy.t
    val x_files_selected : (int -> string) Lazy.t
    val x_files_x_dirs_selected : (int -> int -> string) Lazy.t

  end

  module Menu : sig
    include ContextInit
    val copy : string Lazy.t
    val edit : string Lazy.t
    val open_ : string Lazy.t
    val paste : string Lazy.t
    val save : string Lazy.t
    val save_as : string Lazy.t
  end

  module Popup : sig
    include ContextInit
    val cancel : string Lazy.t
    val close : string Lazy.t
    val no : string Lazy.t
    val yes : string Lazy.t

  end

  module Text_input : sig
    include ContextInit
  end

end (* of I18n *)

(* ---------------------------------------------------------------------------- *)


(** Utilities.

    This module contains several utilities, in particular for debug logs.

{5 {{:graph-dot-b_utils.html}Dependency graph}}
*)
module Utils : sig

  (** {2 Debugging} *)

  val printd : int -> ('a, unit, string, unit) format4 -> 'a
  (** For instance [printd debug_warning "The value x=%u is too big" x] will
     print a message in the console only if the {!debug} variable contains the
     [debug_warning] flag. *)

  val debug : bool ref
  val debug_code : int ref
  (** Logical {e ored} of [!debug] with debug flags (below) controls the amount
     of debuging. *)

  (** {3 Binary masks (=flags) for debugging messages.} *)

  val debug_thread : int
  val debug_warning : int
  val debug_graphics : int
  val debug_error : int
  val debug_io : int
  val debug_memory : int
  val debug_board : int
  val debug_event : int
  val debug_custom : int

  (** {2 Maths} *)

  val pi : float

  val round : float -> int
  (** Round float to nearest integer. *)

  val imax : int -> int -> int
  (** [imax a b] returns max([a], [b]). (Same as [Int.max]). *)

  val imin : int -> int -> int
  (** [imin a b] returns min([a], [b]). (Same as [Int.min]). *)

  (** {2 Tsdl Result} *)

  val go : 'a Tsdl.Sdl.result -> 'a
  (** Transform a [result] into a standard value, or fail with an error. Used
      for SDL functions only. *)

  (** {2 Options}

      Monadic style operations on optional variables. *)

  val map_option : 'a option -> ('a -> 'b) -> 'b option
  (** [map_option o f] is the same as [Option.map f o]. *)

  val do_option : 'a option -> ('a -> unit) -> unit
  (** [do_option o f] is the same as [Option.iter f o]. *)

  val default : 'a option -> 'a -> 'a
  (** [default o v ] is the same as [Option.value o ~default:v]. Warning: [v] is
      evaluated even if it is not used. *)


  exception None_option

  val remove_option : 'a option -> 'a
  (** Like [Option.get]. Warning: [remove_option None] will raise the
     {!None_option} exception. *)

  (** {2 Others} *)

  val ( let@ ) : ('a -> 'b) -> 'a -> 'b

  val run : (unit -> 'a) -> 'a
  (**  [run f] is equivalent to [f ()]. *)

end (* of Utils *)

(* ---------------------------------------------------------------------------- *)


(** Time in msec.

{5 {{:graph-dot-b_time.html}Dependency graph}}
*)
module Time : sig
  type t = int

  val now : unit -> t
  (** Time elapsed from the initialization of SDL (roughly, since the start of
      your program). *)

  val adaptive_fps : ?vsync:bool -> int -> (unit -> unit) * (unit -> unit)
  (** Create helper functions to help controlling the frame rate of the graphics
      loop. This is only useful if you have your own graphics loop, and do not
      use {!Main.run}.

      [adaptive_fps 60] returns two functions [start,fps]. The statement
      [start ()] will start the timing.
      At each iteration of your loop, you should call
      [fps ()], which will try to sleep long enough to achieve the desired 60FPS
      rate. It works on average: if some frames take longer, it will shorten the
      next frame to keep up. However, it tries to be nice to the CPU: even if one
      is really too slow, it will guarantee a 5ms sleep to the CPU and {e not}
      try to keep up.

      [vsync] is [false] by default, when [true] it sets GL swap
      interval to [1] to wait for next vsync, and if it can't keep up
      with that during animation it will set swap interval to [-1] if
      supported by platform to use adaptive vsync.  (Which should
      avoid forcing the animation rate to an integer ratio of monitor
      refresh rate.)

      See also {!Main.get_monitor_refresh_rate}
    *)

end (* of Time *)

(* ---------------------------------------------------------------------------- *)

(** Global variables with mutex.

   In a GUI, it is quite likely that a thread has to modify a variable
   owned by another thread. This is particularly true in Bogue
   (because connections created by {!Widget.connect} use a new Thread
   when executed, unless you specify [~priority:Main]). In order to
   protect against concurrent access to a shared variable, one should
   use a special kind of variable. This is the goal of this module.

   {b Warning:} working with threads is subtle, and using {!Var} will
   not magically make all problems disappear. In particular if two
   variables from two different threads want to access each other, you
   can end up into a stall, and freeze your program.  This can happen
   more often that one thinks, because a Var may contain a {!Layout},
   and we know that sometimes layouts want to modify themselves...

{5 {{:graph-dot-b_var.html}Dependency graph}} *)
module Var : sig
  type 'a t

  val create : 'a -> 'a t
  (** [create v] returns a Var with initial value [v]. *)

  val get :  'a t ->  'a

  val set : 'a t ->  'a -> unit
    (** [set v value] waits until no thread is accessing the Var [v]
        and then sets its value to [value]. *)

  val with_protect : 'a t -> ('a -> 'b) -> 'b
  (** [with_protect v f] applies [f] to the value of [v], while protecting [v]
      from the access of any other thread. *)

  val protect_fn : 'a t -> ('a -> 'b) -> 'b
  (** @deprecated Same as {!with_protect}. *)

end (* of Var *)

(* ---------------------------------------------------------------------------- *)

(** Delayed actions.

{5 {{:graph-dot-b_timeout.html}Dependency graph}}
*)
module Timeout : sig
  type t

  val add : int -> (unit -> unit) -> t
  (** [add delay action] will execute [action ()] (in the main thread) after the
      delay of [delay] ms.
      @return the Timeout element.

      Warning: don't expect the delay to be exact at the ms. The precision
      cannot be better than what the framerate imposes, {e i.e.} usually about
      16ms.

      Note: it is legal for an action to add a new Timeout. *)

  val add_ignore : int -> (unit -> unit) -> unit
  (** Same as [add] except that this does not return the Timeout element. *)

  val cancel : t -> unit
  (** Cancel the Timeout. *)
end (* of Timeout *)

(* ---------------------------------------------------------------------------- *)

(** Dealing with events.

    Events are simply SDL events, plus a few additional events. They are also
    used for primitive communication between threads.

    Events are detected by Layouts, and then sent to the resident
    Widget. Finally, the Widget decides what to do with the events. There is one
    exception: the {!startup} event is directly sent to all Widgets.

    {5 {{:graph-dot-b_trigger.html}Dependency graph}} *)
module Trigger : sig
  type t = Tsdl.Sdl.event_type

  (** {2 SDL events} *)

  val text_input : t
  (** Same as Tsdl.Sdl.Event.text_input *)

  val key_down : t
  (** Same as Tsdl.Sdl.Event.key_down *)

  val key_up : t
  (** Same as Tsdl.Sdl.Event.key_up *)

  (** {2 Special Bogue events} *)

  val startup : t
  (** The [startup] event is sent to all Widgets when the Bogue mainloop is
     started using {!Main.run}. *)

  val mouse_enter : t
  (** The [mouse_enter] event is triggered when the pointer (mouse motion, or
     finger touch -- but not finger drag) enters a new layout. *)

  val mouse_leave : t
  (** Similar to {!mouse_enter}, when the pointer leaves the layout. *)

  val mouse_at_rest : t
  (** Triggered when the mouse did not move for a while. *)

  val var_changed : t
  (** The [var_changed] event can be sent to notify that some widget made a
     change to a global variable. *)

  val update : t
  (** Currently the [update] event is more or less equivalent to
     [var_changed]. This might change in future versions. *)

  val user_event : t
  (** Same as [Tsdl.Sdl.Event.user_event]. This special event of type
      SDL_UserEvent can trigger a global reaction, not associated with any
      widget in particular, through the [on_user_event] parameter of
      {!Main.create} *)

  val buttons_down : t list
  (** A list of events containing the mouse_button_down event, and the
     finger_down event. *)

  val buttons_up : t list
  (** A list of events containing the mouse_button_up event, and the
     finger_up event. *)

  val pointer_motion : t list
  (** A list of events containing the mouse_motion event, and the finger_motion
     event. *)

  (** {2 Using events for terminating threads} *)

  val should_exit : Tsdl.Sdl.event -> bool
  (** Tell if the current thread should exit. This should only be called within
     a widget action. The event should be the event passed to the action
     function. A well programmed action should check this event to decide if it
     should exit. *)
  (* à déplacer dans Widget/connection ? *)

  val will_exit : Tsdl.Sdl.event -> unit
  (** A nice thread should do this just before terminating. May be suppressed in
      future versions. *)

  val nice_delay : Tsdl.Sdl.event -> float -> unit
  (** [nice_delay ev t] Wait during a delay ([t] seconds), but quit anyway when
     {!should_exit}[ ev] is true. *)

  val push_quit : unit -> unit
  (** Send the SDL_QUIT event, as if the user clicked on the close button of the
     last existing window. It will in principle raise the {!Main.Exit}
     exception and hence exit the mainloop. *)

  (** {2 SDL Misc} *)
  val wait_for : ?timeout:float -> ?ev:Tsdl.Sdl.event -> (unit -> bool) -> unit

  (** {2 SDL events} *)

  type sdl_event = Tsdl.Sdl.Event.enum

  type bogue_event =
    [ `Bogue_startup
    | `Bogue_stop
    | `Bogue_stopped
    | `Bogue_mouse_at_rest
    | `Bogue_mouse_enter
    | `Bogue_mouse_leave
    | `Bogue_var_changed
    | `Bogue_keyboard_focus
    | `Bogue_mouse_focus
    | `Bogue_remove_focus
    | `Bogue_destroy_window
    | `Bogue_update
    | `Bogue_sync_action
    | `Bogue_redraw
    | `Bogue_keymap_changed
    | `Bogue_add_window
    | `Bogue_new_mail
    | `SDL_POLLSENTINEL
    ]

  val event_kind : Tsdl.Sdl.event -> [sdl_event | bogue_event]
  (** Union of {!sdl_event} and {!bogue_event} *)

end (* of Trigger *)

(* ---------------------------------------------------------------------------- *)

(** Basic audio mixer for sound effects.

    This simple audio mixer makes it possible to play quick sounds, for instance
    when clicking on buttons, or for game sounds effects.

    Only WAV files are supported. For playing MP3 music, and for more options,
    it is advisable to use the SDL_Mixer library.

    {e Remark:} This module is essentially independent of the rest of Bogue, so
    its source can, with very few modifications, be used for any SDL
    application.

    {e Remark:} Under Windows, using WLS2, it was reported that sound works if
    [wslg] is installed.

    {5 {{:graph-dot-b_mixer.html}Dependency graph}} *)
module Mixer : sig
  type t
  type sound =  (int, Bigarray.int16_signed_elt) Tsdl.Sdl.bigarray
  type repeat = Repeat of int | Forever
  (* How many times we should repeat the sound. *)

  val test : unit -> unit

  val init : unit -> string option
  (** Initialize SDL audio.
      @return the name of the audio driver, or [None] if no audio is
        available. *)

  val create_mixer : ?tracks:int -> ?freq:int -> string option -> t
  (** [create devname] creates the mixer an opens the sound device. If [devname]
      is [None], a dummy mixer is returned, which will produce no sound. Only
      [s16le] format is supported by the callback at this time. The mixer is
      initially paused, you need to {!unpause} it before playing anything. *)

  val load_chunk : t -> string -> sound
  (** Load a WAV file. *)

  val play_chunk : ?track:int ->
    ?effects:(sound -> unit) list ->
    ?volume:float -> ?repeat:repeat -> t -> sound -> int option
  (** Play chunk on the desired track number. If [track] is not specified, find
     an available track. By default [repeat = Repeat 1].
     @return chosen track number, or None *)

  val change_volume : float -> sound -> unit
  (** Multiply sound intensity by a float factor *)

  val pause : t -> unit
  val unpause : t -> unit
  val close : t -> unit

end (* of Mixer *)

(* ---------------------------------------------------------------------------- *)

(** Synchronized execution queue.

    Any action can be pushed to this FIFO queue, in order to be executed by
    Bogue's main loop at the start of the next graphical frame.

    For any action that is not super urgent, it is a good idea to use this
    `Sync` module, instead of launching the action directly from a thread that
    may be difficult to control. In this way, we ensure that the action is not
    executed in the middle of rendering the graphics, or between various
    modifications of the board (events, keyboard focus, etc.).

    {5 {{:graph-dot-b_sync.html}Dependency graph}} *)
module Sync : sig

  val push : (unit -> unit) -> unit
  (** [push action] registers the [action] to be executed by the mainloop at the
      start of the next frame, or at a subsequent frame if the queue is already
      large.

      {b Warning:} the action may also call [push] itself, but since
      there is only one execution queue, the second action will be executed only
      after the first action terminates. For instance this program:

{[Sync.push (fun () ->
    print_endline "push 1";
    Sync.push (fun () ->
        print_endline "push 2";
        print_endline "end 2");
    print_endline "end 1");

print_endline "Creating board";

W.label "Checking sync... see console"
|> L.resident
|> Main.of_layout
|> Main.run]}
      will print:
{v
Creating board
push 1
end 1
push 2
end 2 v}
  *)

end (* of Sync *)
(* ---------------------------------------------------------------------------- *)

(** RGB colors *)
module RGB: sig

  type t = int * int * int
  (** red, green and blue values are integers in the range [0..255] *)

  (** {3 Predefined colors} *)

  include module type of Rgb_names
  val grey : t
  val pale_grey : t
  val dark_grey : t

  (** {3 Theme colors} *)

  val label_color : t
  val set_text_color : t -> unit
  (** Overrides the {!Theme} [TEXT_COLOR] variable. *)

  (** {3 Utils} *)

  val find_color : string -> t
  (** Convert a string of the form ["grey"] or ["#FE01BC"] to a rgb code
      [(r,g,b)]. Color names are taken from
      {{:https://www.rapidtables.com/web/color/html-color-codes.html}here}. *)

  val pale : t -> t

end (* of RGB *)

(** RGBA colors *)
module RGBA: sig

  type t = int * int * int * int
  (** red, green, blue and alpha values are integers in the range [0..255] *)

  (** {3 Predefined colors} *)

  include module type of Rgba_names
  val grey : t
  val pale_grey : t
  val dark_grey : t
  val none : t
 (** [none = (0,0,0,0)] is completely transparent black. *)

  (** {3 Theme colors} *)

  val label_color : t
  val set_text_color : t -> unit
  (** Overrides the {!Theme} [TEXT_COLOR] variable. *)

  (** {3 Utils} *)

  val lighter : t -> t
  val darker : t -> t
  val set_alpha : int -> t -> t
  val transp : RGB.t -> t

  val random_color : unit -> t
  val find_color : string -> t

end (* of RGBA *)


(* ---------------------------------------------------------------------------- *)

(** Low-level graphics and colors.

    This module is internally used for low-level graphics and a thin layer over
    Tsdl.

    The public API is mainly useful for Color management. There are also some
    helper functions for drawing into an {!Sdl_area}.

    {5 {{:graph-dot-b_draw.html}Dependency graph}} *)
module Draw: sig
  type canvas
  (** Contains the hardware information for drawing (SDL renderer and
      window). *)

  type texture = Tsdl.Sdl.texture

  (** {2 Initialization and shutdown} *)

  val video_init : unit -> unit
  (** Manually init the SDL video system, and detect the scaling factor used by
      Bogue. This is useful only if you don't use Bogue's mainloop (for instance
      if you manually manage your windows and event loop). *)

  val quit : unit -> unit
  (** Cleanup and quit SDL. *)

  (** {2 Colors} *)

  type rgb = RGB.t

  type color = RGBA.t

  type fill =
    | Pattern of texture
    | Solid of color

  (** {3 Creating colors} *)

  val opaque : rgb -> color
  val transp : rgb -> color

  val add_alpha : int -> rgb -> color

  val rgba_of_int32 : int -> color

  val find_color : string -> rgb
  (** Same as {!RGB.find_color}. (For backward compatibility) *)

  (** {3 Using colors} *)

  val set_color : Tsdl.Sdl.renderer -> color -> unit
  (** Equivalent to [Sdl.set_render_draw_color]. *)

  val set_text_color : rgb -> unit
  (** Same as {!RGB.set_text_color}. (For backward compatibility) *)


  (** {2:drawing_functions Drawing functions}

      These functions can be used to draw onto an {!Sdl_area.t}. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into hardware pixel coordinates. This
      takes into account both the {!Theme} [SCALE] and the high-dpi scaling of
      some systems (mac OS retina, iOS). *)

  val line : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> x0:int -> y0:int -> x1:int -> y1:int -> unit

  val rectangle : ?thick:int -> Tsdl.Sdl.renderer -> color:color ->
    w:int -> h:int -> x:int -> y:int -> unit
  (** [rectangle renderer ~color ~thick ~w ~h ~x ~y] draws a rectangle with
      given line thickness. The coordinate of the top left corner is
      [(x,y)]. The size (including the thick line) is [(w,h)]. *)

  val circle : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> radius:int -> x:int -> y:int -> unit
  (** [circle renderer ~width ~color ~radius ~x ~y] draws a circle with given
      line thickness, centered at [(x,y)], with given [radius]. *)

  (**/**)
  (** {2 Layers} *)

  (** Layers are used to decide the order of drawing: which graphical elements
      (layouts) should be below, which should be above. For the most part, you
      don't have to access them directly. *)
  type layer

  val use_new_layer : unit -> unit
  (** Use this when you want to switch to a completely different set of layers,
      typically when you want to draw on another window. *)
  (**/**)

  (** {2 Misc} *)

  type align =
    | Min
    | Center
    | Max

  val unscale_size : int * int -> int * int
  (** Transform a size (W,H) in physical pixels into 'logical' pixels (w,h),
     which are used for layouts. This is done by dividing by the {!Theme}
     [SCALE] variable. *)

  val set_system_cursor : Tsdl.Sdl.System_cursor.t -> unit
  (** Set the mouse cursor to be the standard system cursor.  Internally, this
      first creates an SDL system cursor (or use a previously created one). *)

end (* of Draw *)

(* ---------------------------------------------------------------------------- *)

(** Mouse and touchscreen information.

All positions are given in logical pixels, not hardware pixels (see the {!Theme}
   [SCALE] variable).

{5 {{:graph-dot-b_mouse.html}Dependency graph}} *)
module Mouse : sig

  val pointer_pos : Tsdl.Sdl.event -> int * int
  (** Return the pointer current position. This works both for mouse and
     touchscreen. *)

  val pos : unit -> int * int
  (** Get current mouse position. *)

  val window_pos : Tsdl.Sdl.window -> int * int
(** Return the mouse position with respect to the given window, using window
   position if necessary. *)

  val button_pos : Tsdl.Sdl.event -> int * int

  val finger_pos : Tsdl.Sdl.event -> float * float

  val wheel_y : Tsdl.Sdl.event -> int

  val set_wheel_speed : float -> unit
    (** Set the speed of vertical scrolling via the mouse wheel and touchpad. By
        default, wheel speed is 1. for usual vertical scrolling (standard on
        Linux) and -1. for "natural" scrolling (standard on Mac
        OS). [set_wheel_speed 0.] (or any speed less than 0.01) will disable
        mouse wheel scrolling. *)

end (* of Mouse *)

(* ---------------------------------------------------------------------------- *)


(** Transform variables

    Transform variables are a way to share a common data between two widgets,
   when the data has a different meaning (or even a different type) for each
   widget. One widget holds the original value, and the other widget needs to
   apply a {e transformation} each time it wants to read or modify the value.

    For instance you want to share a bank account [b] between Alice in France
   and Bob in the USA. The value is stored by Alice in EUR, and when Bob does
   [get b], he gets the value in USD. Similarly, if he does [set b 50] to put
   50USD on the account, then Alice's value will automatically have the amount
   in EUR.

    What is interesting is that the transformation functions can also have {e
   side-effects}. For instance, send an email each time Bob or Alice modifies
   the amount.

    A more prosaic example would be a slider which shares its value as an
   integer between 0 and 100, and another widget which needs to read/save this
   value as a float between 0 and 1, and each one of them gets notified when the
   other changes the value.

{5 {{:graph-dot-b_tvar.html}Dependency graph}} *)
module Tvar : sig
  type ('a, 'b) t
  (** a transform variable of type [('a,'b)] is a variable of type ['b] attached
     to a variable of type ['a Var.t] by a bi-directional transformation. *)

  val create : 'a Var.t -> t_from:('a -> 'b) -> t_to:('b -> 'a) -> ('a, 'b) t
  val get : ('a, 'b) t -> 'b
  val set : ('a, 'b) t -> 'b -> unit

end (* of Tvar *)

(* ---------------------------------------------------------------------------- *)

(** Animated variables.

    An Avar.t is a variable that evolves in time. It is updated at every frame
   ({e i.e.} every iteration of the main loop). Bogue uses Avars for animations.

{5 {{:graph-dot-b_avar.html}Dependency graph}} *)
module Avar : sig
  type 'a t

  type callback = unit -> unit

  (** {2 Avar creation} *)

  val create : ?duration:Time.t ->
    ?init:callback ->
    ?ending:callback ->
    ?finished:bool -> ?update:('a t -> float -> 'a) -> 'a -> 'a t
  (** Generic Avar creation. If [finished = true], the var never gets further
     updated, {e ie} behaves like a normal variable. Otherwise, the [update]
     parameter is compulsory.

     @param update is a function such that [update v s : 'a] should give the
     value of the Avar [v] at the time [s]. The meaning of the time [s] is
     described in {!progress}. *)

  val apply : ('a -> 'b) -> 'a t -> 'b t
      (** [apply f v] creates a new Avar by composing with f; the old Avar [v]
          is still active *)

  val fromto : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** [fromto x1 x2] creates a integer Avar.t with initial value [x1] and, as
      time elapses, moves continuously to [x2], with a final slowdown. *)

  val fromto_unif : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** Similar to {!fromto} but with uniform speed (no slowdown). *)

  val oscillate : ?duration:int -> ?frequency:float -> int -> int -> int t
  (** [oscillate amplitude x0] will oscillate with the given amplitude around
      the initial value [x0] *)

  val var : 'a -> 'a t
  (** Create an Avar which behaves like a normal Var (no animation). *)

  (** {2 Avar information} *)

  val get : 'a t -> 'a
  (** Start the animation (if necessary) and compute the current value of the
     variable. *)

  val progress : 'a t -> float
  (** [progress v] is a float in \[0,1\] giving the percentage of the animation
     when the last [v.value] was computed. In case of infinite animation, this
     is just the elapsed Time (in ms). *)

  val reset : 'a t -> unit


  (** {2 Misc} *)

  type direction =
    | No
    | Left
    | Right
    | Top
    | Bottom
    | TopLeft
    | TopRight
    | BottomLeft
    | BottomRight
    | Random
end (* of Avar *)

(* ---------------------------------------------------------------------------- *)

(** Unions of ranges of integers

{3:selection_example Example}

We define two sets, [s=[0..5; 10..20]] and [r=[4..15]],
and we compute their union and intersection.

{[
open Bogue.Selection;;
# let s = of_list [(0,5); (10,20)];;
val s : t = <abstr>
# sprint s;;
- : string = "{0..5, 10..20}"
# let r = of_list [(4,15)];;
val r : t = <abstr>
# sprint (union s r);;
- : string = "{0..20}"
# sprint (intersect s r);;
- : string = "{4..5, 10..15}"
]}

{5 {{:graph-dot-b_selection.html}Dependency graph}}
 *)
module Selection : sig
  type t
  val empty : t
  val is_empty : t -> bool

  val size : t -> int
  (** Number of selected integers *)

  val to_list : t -> (int * int) list
  val of_list : (int * int) list -> t
  val range : (int * int) -> t
  val first :  t -> int
  val last : t -> int
  val mem : t -> int -> bool
  val toggle : t -> int -> t
  val remove : t -> int -> t
  val add : t -> int -> t
  val union : t -> t -> t
    (** Not tail-recursive *)

  val intersect : t -> t -> t
  (** Not tail-recursive *)

  val invert : first:int -> last:int -> t -> t
(** [invert ~first ~last sel] returns a selection containing all integers not
    selected in [sel], withing the range [[first, last]]. *)

  val sprint : t -> string
  val iter : (int -> unit) -> t -> unit
  val fold : (int -> 'a -> 'a) -> t -> 'a -> 'a
end (* of Selection *)

(* ---------------------------------------------------------------------------- *)

(** {2 Widgets}

    Widgets are building blocks of the GUI. They also receive all events (mouse
    focus, etc.) and contain the {e intelligence} of your GUI, through {e
    connections} (or callbacks, see {!Widget.connection}). However, in order to
    be displayed, they need to be packed into {e layouts} ({!Layout.t}).

    The main module for dealing with widgets is {!Widget}.

    {b Important:} Each widget possesses two access levels: a frontend and a
    backend.  The frontend has type {!Widget.t} and is used for creation,
    connections, insertion into a layout, and simple access like
    {!Widget.get_text}. The backend contains all the low-level operations to run
    and display the widget; it has a specific type, for instance
    {!Label.t}. Sometimes you want to access these specialized functions;
    for this you may obtain the backend object using the {%html:<a
    href="Bogue.Widget.html#inner">conversion</a>%} (downcasting) functions: for
    instance {!Widget.get_label}.
*)

(** Image widget.

{5 {{:graph-dot-b_image.html}Dependency graph}}
 *)
module Image : sig
  type t

  val create : ?width:int -> ?height:int -> ?noscale:bool -> ?bg:Draw.color ->
    ?angle:float -> string -> t
  (** [create "image.jpg"] will load the image ["image.jpg"]. The actual load
      occurs only once, on the first time the image widget is effectively
      displayed. The image is then stored in a texture. All
      {{:https://wiki.libsdl.org/SDL_image/FrontPage}Sdl_image} image formats are
      supported.

      The file "image.png" will be search in the current Theme
      directory. Absolute paths starting with "/" can also be used.

      @param noscale if [true], the image will appear at the original hardware
      pixel size. By default, [noscale=false] and the image is scaled using the
      {!Theme} [SCALE] variable. *)

  val create_from_svg : ?width:int -> ?height:int -> ?bg:Draw.color -> string -> t
  (** Load an svg image. This requires the [rsvg] or [rsvg-convert] program.

      {e Remark:} With SDL_Image >= 2.0.2, one can use {!create} to load SVG
      files, but the size is not correctly handled (the image will be rendered at
      its 'internal SVG size', and {e then} scaled, which may result in poor
      accuracy).

  *)

  val set_file : t -> string -> unit

end (* of Image *)

(* ---------------------------------------------------------------------------- *)

(** Line and box styles.

{5 {{:graph-dot-b_style.html}Dependency graph}}
 *)
module Style : sig
  type t

  (** not implemented *)
  type line_style =
    | Solid
    | Dotted of (int * int)

  type line
  type border
  type shadow
  type gradient
  type background =
  | Image of Image.t (** pattern image *)
  | Solid of Draw.color
  | Gradient of gradient

  val create : ?background:background -> ?border:border ->
    ?shadow:shadow -> unit -> t
  val empty : t

  val of_bg : background -> t
  val of_border : border -> t
  val of_shadow : shadow -> t
  val with_bg : background -> t -> t
  val with_border : border -> t -> t
  val with_shadow : shadow -> t -> t

  (** {2 Constructing backgrounds} *)

  val theme_bg : background
  val color_bg : Draw.color -> background
  val opaque_bg : Draw.rgb -> background
  val image_bg : Image.t -> background
  val gradient : ?angle:float -> Draw.color list -> background
  val hgradient : Draw.color list -> background
  val vgradient : Draw.color list -> background

    (** {2 Constructing borders} *)

  val mk_line : ?color:Draw.color -> ?width:int ->
    ?style:line_style -> unit -> line
  val mk_border : ?radius:int -> line -> border
  (** Note: currently, a border with positive [radius] is not compatible with a
     transparent background. *)
  (* One could optionally make it possible by using [mask_texture] instead of
     [fast_mask_texture] in box.ml *)

  (** {2 Constructing shadows} *)

  val mk_shadow : ?offset:int * int -> ?size:int -> ?width:int ->
    ?radius:int -> unit -> shadow

end (* of Style *)

(* ---------------------------------------------------------------------------- *)

(** One-line text widget.

A [Label] is a widget for displaying a single line of text.

{5 {{:graph-dot-b_label.html}Dependency graph}}
 *)
module Label : sig
  type t
  type font
  type style = Tsdl_ttf.Ttf.Style.t
  (** See {{:https://sanette.github.io/tsdl-ttf/Ttf/Style/index.html}Ttf.Style}. *)

  val create : ?size:int -> ?font:font -> ?style:style ->
               ?fg:Draw.color -> ?align:Draw.align -> string -> t
  (** Create a new {!Label.t}. Most of the time, you'd rather want to create a
     {!Widget.t} by using {!Widget.label}. *)

  val font_from_file : string -> font
  (** Define a font by specifying a filename of a TTF file. The font will be
      loaded only when needed.  A caching mechanism avoids loading the same font
      several times. If you need to find a font from the theme (or system)
      directory, see {!Theme.get_font_path_opt}. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a {!Label.t} using the name of a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} symbol.  Most
     of the time, you'd rather want to create a {!Widget.t} by using
     {!Widget.icon}. *)

  val set : t -> string -> unit
  (** Modify the text of the label. Does nothing if the given text is already
     the same as the label's previous text. *)

  val set_fg_color : t -> Draw.color -> unit
  (** Modify the color of the text. *)

  val size : t -> int * int
  (** Return the logical size (w,h).
      Warning, a +/- 1 error can be observed due to rounding. *)

end (* of Label *)

(* ---------------------------------------------------------------------------- *)

(** Button widget with text or icon.

{5 {{:graph-dot-b_button.html}Dependency graph}}
*)
module Button : sig
  type t
  type kind =
    | Trigger (* The button always looks "up" when not pressed.*)
    | Switch (* The button is displayed differently on "down" or "up". *)

  val create : ?size:int ->
    ?border_radius:int ->
    ?border_color:Draw.color ->
    ?fg:Draw.color ->
    ?bg_on:Style.background ->
    ?bg_off:Style.background ->
    ?bg_over:(Style.background option) ->
    ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t -> ?state:bool ->
    ?action:(bool -> unit) -> kind -> string -> t
    (** The [action] parameter is executed (with the current button state as
        argument) just after the button state is modified by mouse clicking or
        keyboard (on button up or key up). In order to execute an action that
        depends on the button itself, use {!Widget.on_button_release}
        instead. *)

  val state : t -> bool
  val reset : t -> unit
  val is_pressed : t -> bool
end (* of Button *)

(* ---------------------------------------------------------------------------- *)

(** Slider widget.

{5 {{:graph-dot-b_slider.html}Dependency graph}}
 *)
module Slider : sig
  type t
  type  kind =
    | Horizontal (* horizontal bar with a small slider; NO background *)
    | HBar (* horizontal bar filled up to the value *)
    | Vertical
    | Circular

   (** {2 Creating a Slider widget}

Use {!Widget.slider} or {!Widget.slider_with_action}. *)

  val triggers : Trigger.t list
  (**  The list of events that a Slider can react to. Currently this is the
       concatenation of [Trigger.[buttons_down; buttons_up; pointer_motion]]
       plus [Sdl.Event.key_down]. *)

  (** {2 Getting information} *)

  val size : t -> int * int

  val value : t -> int
  (** Get current value. *)

  val get_max : t -> int

  (** {2 Modifying} *)

  val set : t -> int -> unit
  (** Set a new value. *)

end (* of Slider *)

(* ---------------------------------------------------------------------------- *)

(** Checkbox widget.

{5 {{:graph-dot-b_check.html}Dependency graph}}
 *)
module Check : sig
  type t
  type style

  val create :  ?state:bool -> ?style:style -> unit -> t
  val state : t -> bool

end (* of Check *)

(* ---------------------------------------------------------------------------- *)

(** Multi-line text display widget.

{5 {{:graph-dot-b_text_display.html}Dependency graph}}
 *)
module Text_display : sig
  type t

  type words
  (** An element of type [words] represents a paragraph. *)

  (** {2 Preparing the text} *)

  val example : words
  val raw : string -> words
  val bold : words -> words
  val italic : words -> words
  val normal : words -> words
  val underline : words -> words
  val strikethrough : words -> words
  val para : string -> words
  val paragraphs_of_string : string -> words list

  (** {2 Creating the widget}

       Use {!Widget.text_display} or {!Widget.verbatim} for plain text, or
       {!Widget.html} for a richer display (bold, italics, color, etc.). You may
       also use {!Widget.rich_text} for "rich text" (containing bold, italics,
       etc. using the functions listed above.)
*)

  (** {2 Modifying the widget} *)

  val replace : by:t -> t -> unit
(** [replace ~by:t2 t1] replaces the text content of [t1] by the one of
    [t2]. See also {!Widget.get_text_display}. *)

  val update_verbatim : t -> string -> unit

end (* Text_display *)

(* ---------------------------------------------------------------------------- *)

(** One-line text-input widget.

{5 {{:graph-dot-b_text_input.html}Dependency graph}}
 *)
module Text_input : sig
  type t
  type filter = string -> bool

  val triggers : Trigger.t list
  (** The list of events that a Text_input can react to. Currently this is
      [Sdl.Event.[text_editing; text_input; key_down; key_up]]. *)

  (** {2 Creating the widget}

       Use {!Widget.text_input}
  *)

  val uint_filter : filter
  val text : t -> string

  (** {2 Modifying the widget} *)

  (** Warning: two Text_input widgets cannot be active at the same time. You can
      use {!Sync.push} to delay the activation. *)
  val activate : t -> unit

end (* of Text_input *)

(* ---------------------------------------------------------------------------- *)

(** Box widget.

{5 {{:graph-dot-b_box.html}Dependency graph}}
*)
module Box : sig
  type t

  val create : ?width:int -> ?height:int ->
    ?style:Style.t -> unit -> t

  val set_background : t -> Style.background -> unit

  val set_style : t -> Style.t -> unit

  val get_style : t -> Style.t

end (* of Box *)

(* ---------------------------------------------------------------------------- *)

(** SDL Area widget.

    You can use an Sdl_area widget to draw whatever you want using all the power
    of the
    {{:https://erratique.ch/software/tsdl/doc/Tsdl/Sdl/index.html#renderers}SDL
    renderer API}.

    Technically, an Sdl_area widget contains an SDL texture and sets it as a {e
    render target}.

    SDL commands are sent to the Sdl_area using {!add} (and stored in a command
    queue). You can also use {!add_get} in order to get a handle on the command
    in case you reserve the possibility to remove the command with
    {!remove_element}.

{5 {{:graph-dot-b_sdl_area.html}Dependency graph}} *)
module Sdl_area : sig
  type t

  val create : width:int -> height:int ->
    ?style:Style.t -> ?timeout:int -> unit -> t
  (** Create an empty SDL area. Note that the given size [(width,height)] is the
      {e logical} pixel size of the area. The physical size, to be used for most
      SDL rendering functions, can be obtained with {!drawing_size}. *)

  val update : t -> unit
  (** Force the area to be re-drawn at the next graphics frame. *)

  val clear : t -> unit
  (** Clear the area (this removes all commands from the render queue). *)

  val add : t -> ?name:string -> (Tsdl.Sdl.renderer -> unit) -> unit
  (** [add area ~name f] adds the arbitrary command [f] to the render queue.
     The command should be fast, otherwise it will block the UI when the queue
     is executed. For long drawings, it's better to split them into many
     commands. If you need the possibility to remove a command later, use
      {!add_get} instead. *)

  val cache :  t -> unit
  (** This will insert a special command in the queue that will save the texture
     obtained at that point, and clear all previous commands in the
     queue. Commands added to the queue after the [cache] invocation are not
     removed. Further updates to the area will show the cached texture and then
     execute the rest of the queue. Use this only for performance reasons when
     the rendering queue uses a lot of power and/or time. *)

  val clear_cache : t -> unit
  (** Clear the graphics cache generated by the {!cache} command. It has no
     effect if no cache was created. Clearing the cache does {e not} restore the
     commands in the queue that were used to draw it. *)

  (** {2 Drawing functions and utilities}

      Shortcuts to some {%html:<a href="Bogue.Draw.html#drawing_functions">
      drawing functions</a>%} from the {!Draw} module.

      For more sophisticated shapes (and faster rendering), consider using the
      {{:https://github.com/fccm/tsdl-gfx}tsdl_gfx} external library or,
      better, the companion {{:https://github.com/sanette/bogue-cairo}bogue-cairo} library.  *)

  val drawing_size : t -> (int * int)
  (** Size in physical pixels of the target SDL texture on which you can
     draw. You may also use [Tsdl.Sdl.get_renderer_output_size], if used inside
      the Sdl_area command queue. *)

  val pointer_pos : t -> Tsdl.Sdl.event -> int * int
  (** Position of the pointer (mouse or touchscreen that has generated the
     event) in physical pixels, with respect to the top-left corner of the
     Sdl_area. Should be called only after the Sdl_area has been rendered. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into pixel coordinates usable for the
     SDL area. Same as {!Draw.to_pixels}. *)

  val draw_line : t -> color:Draw.color -> thick:int ->
    int * int -> int * int -> unit
  (** [draw_line c ~color ~thick (x1, y1) (x2, y2)] draws a line of given
      [color] and [thick]ness from point [(x1, y1)] to point [(x2, y2)]. *)

  val draw_rectangle : t -> color:Draw.color -> thick:int ->
    w:int -> h:int -> int * int -> unit
  (** [draw_rectangle c ~color ~thick ~w ~h x0 y0] draws a rectangle of the
        given line thickness {e inside} the box of top-left coordinates [(x0,
        y0)], width [w] and height [h]. *)

  val fill_rectangle : t -> color:Draw.color ->
    w:int -> h:int -> int * int -> unit

  val draw_circle : t -> color:Draw.color -> thick:int -> radius:int ->
    int * int -> unit
  (** [draw_circle c ~color ~thick ~radius (x0, y0)] draws a circle of the given
     line [thick]ness and [color] {e inside} the disc of center coordinates
     [(x0, y0)] and given [radius].


      An example of [draw_circle] is provided by Example #50 (it can be run from
     the terminal with [boguex 50]), which produces the following picture:

      {%html:<div class="figure"><img src="images/example50.png"></div>%}

      The source code for all [boguex] examples is
     {{:https://github.com/sanette/bogue/blob/master/examples/examples.ml}here}.

  *)

  val fill_circle : t -> color:Draw.color -> radius:int -> int * int -> unit


  (** {2 Draw elements}

      The command queue can be manipulated. An element of this queue is called a
      [draw_element].  *)

  type draw_element

  val add_get : t -> ?name:string -> ?disable:bool -> (Tsdl.Sdl.renderer -> unit)
    -> draw_element
  (** Similar to {!add}, but returns the corresponding {!draw_element}.  If
     [disable] is true, the command will not be executed. *)

  val disable : draw_element -> unit
  (** Mark an element for skipping its execution. *)

  val enable : draw_element -> unit
  (** See {!disable}. *)

  val remove_element : t -> draw_element -> unit
  (** Remove the {!draw_element} from the command queue. *)

  val add_element : t -> draw_element -> unit
  (** Append the element to the end of the command queue. *)

  val has_element : t -> draw_element -> bool
  (** Check whether the element belongs to the command queue. *)

  (** {2 Direct access to the texture} *)

  val get_texture : t -> Tsdl.Sdl.texture option

  val set_texture : t -> Tsdl.Sdl.texture -> unit

end (* of Sdl_area *)

(* ---------------------------------------------------------------------------- *)

(** Empty widget.

    {5 {{:graph-dot-b_empty.html}Dependency graph}}
 *)
module Empty : sig
  type t

  val on_unload : t -> (unit -> unit) -> unit

end (* of Check *)

(* ---------------------------------------------------------------------------- *)


(* ---------------------------------------------------------------------------- *)

(** Creating widgets and giving life to them

Widgets are simple graphic elements that can react to user interaction. They are
   the inhabitants of your GUI house. When a widget is woken up by some event,
   it can talk to another widget by means of a [connection].

{5 {{:graph-dot-b_widget.html}Dependency graph}} *)
module Widget : sig
  type t
  (** The type {!t} is a union of all kinds of widgets: Box, Button, Check box,
     Image, Label, Slider, Text display, and Text input, plus the Empty
     widget.

For instance, in the following code:
{[
let w = label "Hello" in
let l = get_label w in
...
]}
[w] has the generic {!t} type, while [l] has the specialized {!Label.t} type.
*)

  (** {2:connections Connections}

      A connection has a source widget and a target widget. When the source
     widget receives a specified event, the connection is activated, executing a
     specified function, which is called {!action}.

     An action is always executed in a new Thread (and hence will not block the
     GUI), unless the priority [Main] is specified.

      If a widget possess several connections which react to the same event, the
      order of execution of these connections is the same as the order they were
      registered.  *)

  type connection

  type action = t -> t -> Tsdl.Sdl.event -> unit
  (** An action is a function with three parameters [w1 w2 ev], where
     [w1] is the source widget, [w2] the target widget, and [ev] the event
     ({!Trigger.t}) that triggered the action.

     The action should regularly verify {!Trigger.should_exit}[ ev] and quickly
     exit when that function returns [true].
*)

  (** What happens when an event triggers an action while the same action (=
      same connection id) is already running? Several behaviours are possible,
      depending on the following {!action_priority} type. *)

  type action_priority =
    | Forget (** discard the new action *)
    | Join (** execute the new after the first one has completed *)
    | Replace (** kill the first action (if possible) and execute the second one
                 *)
    | Main (** run in the main program. So this is blocking for all subsequent
              actions *)

  val connect : t -> t -> action -> ?priority:action_priority ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** [connect source target action triggers] creates a connection from the
      [source] widget to the [target] widget, but does not register it ({e this
      may change in the future...}). Once it is registered (either by
      {!Main.create} or {!add_connection}), and assuming that the layout
      containing the source widget has {e focus}, then when an event [ev]
      matches one of the [triggers] list, the [action] is executed with
      arguments [source target ev].

      @param priority indicates the desired priority policy. Default is [Forget].

  *)

  val connect_main : t -> t -> action ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** Alias for [connect ~priority:Main]. Should be used for very fast actions
      that can be run in the main thread. *)

  val add_connection : t -> connection -> unit
  (** Registers the connection with the widget. This should systematically be
     done after each connection creation, when the connection is created {e
     after} {!Main.create}.

     Connections that are created {e before} {!Main.create} should rather be
     passed as argument to {!Main.create}, and {e not} via
     [add_connection]. Although this is not strictly necessary, this indicates
     that these connections are more 'pure' or at least more static, in the
     sense that they will not be modified by Bogue. These are usually much
     easier to debug.

     {e [add_connection] is separated from {!connect} because it is not pure: it
     mutates the widget. This might change in future versions.} *)

  val remove_connection : t -> connection -> unit
  (** Unregister the connection. If the connection was already triggered and the
      corresponding action is active, the action will not be cancelled. *)

  val remove_trigger : t -> Trigger.t -> unit
  (** Remove all the connections from the given widget that respond to the given
      trigger (=event) *)

  val update : t -> unit
  (** [update w] asks the widget [w] to refresh at next frame. The most probable
     use of [update] is within the code of an {!action}. It can happen that the
     action modifies the visual state of a widget that is neither the source or
     the target, and then one needs to explicitly tell this widget to re-draw
     itself.  *)

  (** {3 Predefined connections} *)

  val on_release : release:(t -> unit) -> t -> unit
  (** [on_release ~release:f w] registers on the widget [w] the action [f],
      which will be executed when the mouse button is released on this widget.
      {e Uses [priority=Main]} *)

  val on_button_release : release:(t -> unit) -> t -> unit
  (** Similar to {!on_release} but specialised to button widgets. It also checks
      the key used to activate buttons (currently, the Return key). *)

  val on_click : click:(t -> unit) -> t -> unit
  (** {e Uses [priority=Main]} *)

  val mouse_over : ?enter:(t -> unit) -> ?leave:(t -> unit) -> t -> unit


  (** {2:widget_create Creation of Widgets}

As a general rule, widgets should be created using the functions below, which
belong to the Widget module and create an element of type {!t}. However, for
some specialized usage, additional features may be available from the widget
underlying module (eg. {!Label}, {!Box}, etc.).
See the {{!inner}conversion functions} below. *)

  (** {3 Simple boxes (rectangles)} *)

  val box :
     ?w:int -> ?h:int -> ?style:Style.t -> unit -> t
  (** Create a Box widget, which simply displays a rectangle, optionally with
     rounded corners and drop shadow. It is often used for the background of a
     group of widgets (i.e. a {!Layout.t}). *)

  (** {3 Check boxes}
      The standard on/off check boxes. *)

  val check_box : ?state:bool -> ?style:Check.style -> unit -> t
  val set_check_state : t -> bool -> unit

  (** {3 Text display}
      Use this for multi-line text. *)

  val text_display :  ?w:int -> ?h:int -> string -> t
  (** The string may contain newlines. The text will be wrapped to fit the
      required width. This width is either the [~w] parameter, or the width of
      the container in case the layout is resized. If the height [~h] is
      provided, the end of the text that does not fit may be discarded (but may
      reappear after resizing).

      If [~w] is not provided, the initial widget width will default to 256.

      If neither [~w] nor [~h] are provided, the initial widget size will
      default to (256, 128).

      Immediately after creation, the widget size can be obtained by
      {!size}.

      @see "Example #1h".*)

  val rich_text : ?size:int -> ?w:int -> ?h:int -> Text_display.words list -> t
  (** @see "Example #1v". *)

  val verbatim : string -> t

  val html : ?w:int -> ?h:int -> string -> t
  (** Display basic html text by interpreting the following tags:
      [<em>,</em>, <b>,</b>, <strong>,</strong>, <u>,</u>, <p>,</p>, <br>]
      and also a color selector with [<font color="???">, </font>]. The "???"
      string should be replaced by a color code, either RGB like "#40E0D0" or
      "#12C", or RGBA like "#40E0D0AA" or "#12CA", or a color name like
      "darkturquoise".

      @see "Example #47". *)

  (** {3 Labels or icons} *)

  val label : ?size:int -> ?fg:Draw.color -> ?font:Label.font -> ?style:Label.style ->
    ?align:Draw.align -> string -> t
  (** Create a Label widget with a one-line text. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a Label widget with a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} icon.

     For instance [icon ~size:24 "star"] creates a widget that displays the
     "fa-star" fontawesome icon. *)

  (** {3 Empty} *)

  val empty : ?unload:(unit -> unit) -> w:int -> h:int -> unit -> t
  (** Create a widget that does not display anything but still gets focus and
      reacts to events. Optionally, execute an action when the widget is not
      "used" anymore (that is to say when the containing layout is removed from
      the board.) *)

  (** {3 Image} *)

  val image : ?w:int -> ?h:int -> ?bg:Draw.color ->
    ?noscale:bool -> ?angle:float -> string -> t
  (** Load image file. *)

  val image_from_svg : ?w:int -> ?h:int -> ?bg:Draw.color -> string -> t
  (** Requires [rsvg]. *)

  val image_copy : ?rotate:float -> t -> t
  (** Return a new "Image" widget linked to the same image (same underlying
     [Image.t], hence same texture.) *)

  (** {3 Text input} *)

  val text_input : ?text:string -> ?prompt:string ->
    ?size:int -> ?filter:Text_input.filter -> ?max_len:int -> unit -> t
  (** [size] is the font size. [max_len] is the maximum number of chars
      allowed. The [prompt] is used to display a message when there is no user
      input. It also influences the size of the widget.  *)

  (** {3 Buttons} *)

  val button : ?kind:Button.kind -> ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t ->
    ?fg:Draw.color ->
    ?bg_on:Style.background -> ?bg_off:Style.background ->
    ?bg_over:(Style.background option) ->
    ?state:bool ->
    ?border_radius:int -> ?border_color:Draw.color ->
    ?action:(bool -> unit) -> string -> t

  (** {3 Sliders} *)

  val slider : ?priority:action_priority -> ?step:int -> ?value:int ->
    ?kind:Slider.kind ->
    ?var:(int Avar.t, int) Tvar.t ->
    ?length:int -> ?thickness:int -> ?tick_size:int -> ?lock:bool ->
    ?w:int -> ?h:int -> int -> t
  (* The size of the slider is given either by [w,h] or [length, thickness]. The
     interpretation of [length] and [thickness] depends on [kind]. *)

  val slider_with_action : ?priority:action_priority ->
    ?step:int -> ?kind:Slider.kind -> value:int -> ?length:int ->
    ?thickness:int -> ?tick_size:int -> action:(int -> unit) -> int -> t
  (** Create a slider that executes an action each time the local value of the
     slider is modified by the user. *)

  (** {3 Sdl Area} You can use an Sdl_area widget to draw whatever you want
     using all the power of the SDL Renderer API. *)

  val sdl_area : w:int -> h:int -> ?style:Style.t -> unit -> t
  (** See {!Sdl_area.create} regarding the size [(w,h)]. *)

  (** {2 Creation of combined widgets} *)

  val check_box_with_label : string -> t * t
  (** [let b,l = check_box_with_label text] creates a check box [b], a label
     [l], and connect them so that clicking on the text will also act on the
     check box. *)

  (** {2 Generic functions on widgets}

      These generic functions work on all types of widgets, and emit an error in
     the log (without raising any exception) whenever the type of the argument
     makes no sense for the function.

      These functions are very handy, but sometimes can hide a bug. For instance
     if you want to use [get_state t], while you know that [t] should always be
     of type [Button], then it will help debugging to use instead the slightly
     longer form {!Button.state}[ (get_button t)]. Indeed the latter will fail
     if [t] happens not to be a Button.

*)

  val get_state : t -> bool
  (** Query a boolean state. Works for Button and Check. *)

  val get_text : t -> string
  (** Return the text of the widget. Works for Button, TextDisplay, Label, and
     TextInput. *)

  val size : t -> int * int
  (** If the widget is not rendered yet, a default size may be returned instead
     of the true size. *)

  val set_state : t -> bool -> unit
  (** Set a boolean state. Works for Button and Check. *)

  val set_text : t -> string -> unit
  (** Change the text of a widget. Works for Button, TextDisplay, Label,
     and TextInput. *)

  val set_cursor : t -> Tsdl.Sdl.cursor option -> unit
  (** Set the cursor that should be displayed for this widget. Note that the Sdl
     functions for creating cursor are only available after SDL
     initialization. One can use a [Lazy] type or {!Sync.push} for delaying
     their execution. *)

  (** {2:inner Conversions from the generic Widget type to the specialized inner type}

      (Or: frontend to backend.)  These functions raise [Invalid_argument]
      whenever their argument is not of the correct type.  *)

  val get_box : t -> Box.t
  val get_button : t -> Button.t
  val get_check : t -> Check.t
  val get_empty : t -> Empty.t
  val get_image : t -> Image.t
  val get_label : t -> Label.t
  val get_sdl_area : t -> Sdl_area.t
  val get_slider : t -> Slider.t
  val get_text_display : t -> Text_display.t
  val get_text_input : t -> Text_input.t

  (** {2 Generic actions} *)

  val map_text : (string -> string) -> action
  (** [map_text f] is a {!action} that replaces the text of the second widget
     by [f] applied to the text of the first widget. *)

end (* of Widget *)

(* ---------------------------------------------------------------------------- *)

(** Updating widgets

{5 {{:graph-dot-b_update.html}Dependency graph}}
*)
module Update : sig

  val push : Widget.t -> unit
  (** Register a widget for being updated (at next frame) by the main loop. *)

end (* of Update *)

(* ---------------------------------------------------------------------------- *)

(** Sending arbitrary messages to widgets

    Working with messages can go a long way simplifying an intricate GUI.


    Technically, Mailboxes are build upon Bogues's {e connections}, and can be
    seen as a (semantic) extension to the simple {!Update} mechanism. Mailboxes
    can be useful

    + for letting two widgets talk together in suitations where they are far
    away from each other in the code (distinct scopes), making the use of standard connections
    difficult.
    + for avoiding recursivity issues: widgets can "send orders" at places
    in the code where the way to achieve theses orders are not even defined yet.
    + more generally, for rethinking all or part of your UI logic to delegate
    decision making to a few "decision centers" (the mail handlers).

    WARNING: new API, not stabilized yet.

    {5 {{:graph-dot-b_mailbox.html}Dependency graph}}
*)
module Mailbox : sig

  type 'a mbx

  val create : ?owner:Widget.t -> unit -> 'a mbx
  (** Create an empty mailbox which will receive messages of type
      ['a].

      Specifying an [owner] widget is optional (and may disappear in future
      API); it {e could} help structuring the code: we think of it as "the
      widget that handles the incoming mail".

      Once a mailbox is created, anyone can send messages to it using
      {!send}. However the mail will be effectively handled only once
      {!activate} is called.

      @see "Example #57".

  *)


  val activate: ?sync:bool -> 'a mbx -> ('a -> unit) -> unit
  (** [activate mbx handler] sets the owner widget ready to receive messages,
      and each received message will be handled by the [handler] function.

      By default, "the mailman delivers at each frame": messages are handled one
      by one in the {!Sync} queue, in the order of reception (FIFO). Setting
      [sync=false] will on the contrary execute the handler in a separate
      thread. (Only one thread per mailbox.)

      Note that all messages are transfered to the handler as soon as the first
      delivery occurs, so in principle the handler is authorized itself to send
      new messages to its own mailbox. Of course if all messages trigger sending
      a new one, this will loop forever.*)

  val send : 'a mbx -> 'a -> unit
  (** [send mbx msg] sends the message [msg] to the mailbox [mbx].

      Recall that all messages sent to a given mailbox must be of the same
      type. It can be handy to use polymorphic variants like

      {[send mbx (`Start_new_level 7)]}

      Even if the mailbox is not activated, or disabled, messages can still be sent:
      they accumulate in the mailbox queue, and will all be handled once the
      mailbox is activated or re-enabled.

  *)

  val enable : 'a mbx -> unit
  val disable : 'a mbx -> unit
  val clear : 'a mbx -> unit

end (* of Mailbox *)

(* ---------------------------------------------------------------------------- *)


(** {2 Layouts}

    Layouts are rectangular graphical placeholders, in which you should pack all
   your widgets in order to display your GUI. Sophisticated gadgets are usually
   obtained by combining several layouts together.  *)


(** The main, all-purpose graphics container.

 A layout is a "box" (a rectangle) whose purpose is to place onscreen the
 various elements composing the GUI. It can contain a single widget, or a list
 of sub-layouts (recursively). In Bogue, we use the housing metaphor: a layout
 is a {b house} that contains either a single {b resident}, or several {b
 rooms}. Each room can be seen as a sub-house, and can contain a resident or
 sub-rooms. Houses and rooms have the type {!t}, while a resident has the type
 {!Widget.t}.

     Technically, the usual metaphor in computer science is a {e Tree}. A layout
   is a tree, each vertex (or node) has any number of branches (or children). A
   leaf (terminal node: without any child) is either empty or contains a
   widget. However, the tree is upside-down (as often): we think of the trunk
   (or {e top-layout}) to be a the top, and the leaves at the bottom.

{5 {{:graph-dot-b_layout.html}Dependency graph}} *)
module Layout : sig
  type t

  exception Fatal_error of (t * string)

  type room_content =
    | Rooms of t list
    | Resident of Widget.t

  (** Not implemented. *)
  type adjust   =
  | Fit
  | Width
  | Height
  | Nothing

  (** {2 Backgrounds} *)

  (** Warning, the [background] type corresponds actually to the {!Style.t}
     type, which means it includes color backgrounds, image patterns, corner and
     shadow styles. *)
  type background

  val color_bg : Draw.color -> background
  (** Construct a background from an RGBA color.*)

  val opaque_bg : Draw.rgb -> background
  (** Construct a background from an RGB (ie non-transparent) color. *)

  val style_bg : Style.t -> background
  (** Construct a background from the given [Style]. *)

  val theme_bg : background
  (** This is the background constructed from the current theme's BG_COLOR. *)

  val set_background : t -> background option -> unit

  val unload_background : t -> unit
  (** Free the texture associated with the background (if any). This can be used
     to force recreating it. *)

  (** {2 Resize strategies for {!flat} and {!tower}} *)
  module Resize : sig
    type strategy =
      | Disable (** Don't resize (and cancel the rooms resize functions). *)
      | Linear (** Scale only in one direction, horizontal or vertical depending
                   on function (flat or tower). *)
      | Default (** Default resizing strategy: scale dimensions and positions
                    with respect to the layout size.*)
  end

  (** {2 Creation of layouts}

      Remark: all layouts have an optional [name] property, which is used only
     for debugging. *)

  val empty : ?name:string -> ?background:background ->
              w:int -> h:int -> unit -> t
  (** An empty layout can reserve some space without stealing focus. *)

  (** {3 Create layouts from widgets} *)

  val resident :
    ?name:string -> ?x:int -> ?y:int -> ?w:int -> ?h:int ->
    ?background:background ->
    ?draggable:bool ->
    ?canvas:Draw.canvas ->
    ?keyboard_focus:bool -> Widget.t -> t
  (** Create a layout (=room) from a single Widget (=resident). The content of
     such a layout cannot be modified. *)

  val flat_of_w :
    ?name:string -> ?sep:int -> ?h:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas ->
    ?resize:Resize.strategy ->
    ?clip:bool ->
    Widget.t list -> t
  (** Horizontal arrangement of widgets. See {!flat}. *)

  val tower_of_w :
    ?name:string -> ?sep:int -> ?w:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas ->
    ?resize:Resize.strategy ->
    ?clip:bool ->
    Widget.t list -> t
    (** Vertical arrangement of widgets. See {!tower}. *)

  (** {3 Create layouts from other layouts} *)

  val flat :
    ?name:string -> ?sep:int ->
    ?adjust:adjust -> ?hmargin:int -> ?vmargin:int -> ?margins:int ->
    ?align:Draw.align ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas ->
    ?resize:Resize.strategy ->
    ?clip:bool -> t list -> t
  (** Create a horizontal arrangement from a list of rooms.
      + [sep] = horizontal space between two rooms (except on the right hand side
      of a room of zero width).
      + [hmargin] = horizontal margin (left and right).
      + [vmargin] = vertical margin (top and bottom).
      + if [margins] is set, then sep, hmargin and vmargin are all set to this value.
  *)

  val tower :
    ?name:string -> ?sep:int ->
    ?margins:int -> ?hmargin:int -> ?vmargin:int ->
    ?align:Draw.align -> ?adjust:adjust ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas ->
    ?resize:Resize.strategy ->
    ?clip:bool -> t list -> t
  (** Create a vertical arrangement from a list of rooms. See {!flat}. *)

  val superpose :
    ?w:int -> ?h:int -> ?name:string ->
    ?background:background -> ?canvas:Draw.canvas -> ?center:bool ->
    ?scale_content:bool ->
    t list -> t
  (** Create a new layout by superposing a list of layouts without changing
      their (x,y) position. Warning: if a room in a [superpose] layout is later
      moved out of the bounding box, it will never get mouse focus. *)

  (** Remark: when creating a house (a layout) with [flat*], [tower*], or
      [superpose], the size of the inner rooms will be automatically updated
      whenever the size of the house is modified. However, as soon as one
      manually sets the size or the position of a room inside this house with
      {!set_width}, {!setx} and likes, then the room will stop reacting to
      changes of the house size. *)

  (** {2 Some useful layout combinations} *)

  val make_clip : ?w:int ->
    ?scrollbar:bool ->
    ?scrollbar_inside:bool -> ?scrollbar_width:int ->
    ?on_scroll:(int -> unit) -> h:int -> t -> t
  (** Clip a layout inside a smaller container and make it scrollable, and
      optionally add a scrollbar widget. The [on_scroll] function is called
      anytime the scroll is modified, with the vertical offset as
      parameter.

      Currently, only vertical scrolling is implemented. The [?w] variable is
      not used.

      @see "Example #27". *)

  (** {2 Get layout attributes} *)

  val xpos : t -> int
  (** get current absolute x position of the layout (relative to the top-left
     corner of the window). Not necessarily up-to-date. *)

  val ypos : t -> int
  (** see {!xpos} *)

  val width : t -> int
  val height : t -> int
  val get_size : t -> int * int
  (** [get_size l] is equivalent to [(width l, height l)] *)

  val get_physical_size : t -> int * int
  (** multiplies [get_size] by the Theme scaling factor. This gives in principle
     the correct size in physical pixels, up to an error of +/- 1pixel, due to
     rounding error. *)

  val getx : t -> int
  (** Compute the relative x position of the room with respect to its house,
     using animations if any. Because of this, this function should not be
      called by the animation itself! Use {!get_oldx} instead.  *)

  val get_oldx : t -> int
  (** Return the last computed value for the relative x position of the
     layout. *)

  val gety : t -> int
  val get_oldy : t -> int

  val is_shown : t -> bool

  val widget : t -> Widget.t
  (** Return the resident widget, or
      @raise Not_found if the layout is not a {e leaf}. *)

  val top_house : t -> t
  (** Return the top of the layout tree (the "house" that contains the given
     layout and that is not contained in another layout). It is the only layout
     that is directly attached to a "physical" (SDL) window. *)

  val get_content : t -> room_content

  val get_rooms : t -> t list

  val has_resident : t -> bool

  (** {2 Modify existing layouts}

      Layouts should be modified only by the main Thread. If you want to modify
      a Layout within a {!Widget.connection} without [Main] priority,
      you should use {!Sync.push}, or properly lock it using
      {!lock}/{!unlock}.  *)

  val auto_scale : t -> unit
  (** Set the layout to automatically scale its inner rooms when the layout size
     is modified. *)

  val resize_keep_margins : ?margin:int ->
    ?min_width:int -> ?min_height:int -> ?max_width:int -> ?max_height:int ->
    t -> unit
  (** When asked to resize, the layout will keep the initial 4 margins with
     respect to its house. *)


  val disable_resize : t -> unit
  (** This makes sure that nothing is executed when someone tries to resize the
      layout (that is, when the size of the layout's house changes). Warning;
      working with resize functions is tricky. [disable_resize] should in
      general be called {e after} the layout has been installed in a house, see
      comments for {!on_resize}. *)

  val on_resize : t -> (unit -> unit) -> unit
  (** [on_resize room f] will execute [f ()] upon resizing the room's house (or
      the room's window, in case the room is the top house, see {!top_house}),
      in addition to the already registered resize functions. Warning: placing
      the room in another layout will likely reset the resize function (unless
      you set the [resize] flag to [Keep], see eg. {!flat} and the remark below
      that). Hence [on_resize] should be called after the room is hosted in its
      house. *)

  val set_width : ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
    -> t -> int -> unit
  (** [set_width] and similar functions will not work if there is an animation
      running acting of the variable we want to set (here, the width). Most of
      these functions will stop the automatic resizing mechanism of the
      room. Use {!auto_scale} to reactivate it. *)

  val set_height : ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int -> unit
  val set_size : ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool ->
    ?w:int -> ?h:int -> t -> unit
  val setx : ?keep_resize:bool -> t -> int -> unit
  val sety : ?keep_resize:bool -> t -> int -> unit
  val set_show : t -> bool -> unit

  val set_shadow : t -> Style.shadow option -> unit

  val fix_content : t -> unit
  (** Disable automatic resizing of the rooms inside this layout. *)

  val fit_content : ?sep:int -> t -> unit
  (** Adapt the size of the layout (and their houses) to the disposition of the
     contained rooms. *)

  val set_rooms : t -> ?sync:bool -> t list -> unit
  (** Modify the layout content by replacing the former content by a new list of
      rooms. Use [sync=true] (the default) as much as possible in order to avoid
      multi-threading problems. Then the changes will be applied by the main
      thread at next frame (see {!Sync}). *)

  val replace_room : by:t -> t -> bool
  (** Replace [room] by [by] inside its "house" in lieu and place of the initial
      room. No size adjustments are made.

      Using [replace_room] can be dangerous, because it modifies both the
      [room]'s house and [by]. Beware of circular dependencies...

      This function cannot be used for the [top_house] (the window layout)
      because that layout has no house. Also, the function not accept to proceed
      if [by] already belongs to a house.

      @return [true] if successful. *)

  val set_enabled : t -> bool -> unit
  (** Disable or enable a layout and all its rooms recursively. A disabled
      layout will not accept any mouse or keyboard focus. *)

  val iter_unload_textures : t -> unit
  (** Use this to free the textures stored by the layout (and its children) for
     reducing memory. The layout can still be used without any impact, the
     textures will be recreated on the fly.  *)

  val lock : t -> unit
  val unlock : t -> unit
  (** In general, modifying a layout should by done by the main Thread or by
      using a {!Sync.push}. However, in case you need a layout to be modified by
      different threads, you should lock it with {!lock}. Once a layout is
      locked, another [lock] statement from another thread will wait for the
      previous lock to be removed by {!unlock}. Locking twice by the same thread
      is allowed, and will not block, which allows recursive locking, but this
      practice should be avoided because it is difficult to debug. If you need a
      higher level locking API, wrap the layout in a {!Var.t} variable. *)



  (** {2 Animations}

      Position, size, alpha channel, and rotation of Layouts use [Avar]
     variables and hence can be easily animated. Most predefined animations have
      a default duration of 300ms. *)

  (** {3 Generic animations}

      These functions assign an animated variable if type {!Avar.t} to one
     of the properties of the layout (position, width, etc.)  *)

  val animate_x : t -> int Avar.t -> unit
  (** Assign an Avar to the layout x position. *)

  val animate_y : t -> int Avar.t -> unit
  val stop_pos : t -> unit
  (** Stop animations of the variables x and y. *)

  val animate_w : t -> int Avar.t -> unit
  val animate_h : t -> int Avar.t -> unit
  val animate_alpha : t -> float Avar.t -> unit
  val animate_angle : t -> float Avar.t -> unit

  (** {3 Predefined animations} *)

  val hide : ?duration:int -> ?towards:Avar.direction -> t -> unit
  (** See {!show}. *)

  val show : ?duration:int -> ?from:Avar.direction -> t -> unit
  (** Does nothing if the layout is already fully displayed. Only the
     [Avar.Top] and [Avar.Bottom] directions are currently implemented. For
     these directions, [hide] and [show] do {e not} modify the position
     variables (x,y) of the layout, they use a special variable called
     [voffset]. *)

  val fade_in : ?duration:int -> ?from_alpha:float -> ?to_alpha:float ->
    t -> unit
  (** Animate the alpha channel of the layout. Can be combined with animations
     involving the other animated variables. Does {e not} modify the [show]
     status of the layout. By default, [from_alpha=0.] (transparent) and
      [to_alpha=1.]  (opaque).  *)

  val fade_out : ?duration:int ->
    ?from_alpha:float -> ?to_alpha:float -> ?hide:bool -> t -> unit
  (** See {!fade_in}. WARNING: fading out to alpha=0 results in a completely
     transparent layout, but the layout is {e still there} (it's not
     "hidden"). Which means it can still get mouse focus. If you want to hide
     it, then use [hide=true]. By default, [hide=false], [from_alpha] is the
     current alpha of the layout, and [to_alpha=0.] *)

  val rotate : ?duration:int -> ?from_angle:float -> angle:float -> t -> unit
  (** Rotate all widgets inside the layout around their respective centers. For
      a global rotation, use a {!Snapshot}. *)

  val slide_in : ?duration:int -> ?from:Avar.direction -> ?dst:t -> t -> unit
  val slide_to : ?duration:int -> t -> int * int -> unit
  (** [slide_to room (x0,y0)] will translate the [room] to the position
     [(x0,y0)]. *)

  val follow_mouse : ?dx:int -> ?dy:int ->
    ?modifierx:(int -> int) -> ?modifiery:(int -> int) -> t -> unit
  val oscillate : ?duration:int -> ?frequency:float -> int -> t -> unit
  val zoom : ?duration:int -> from_factor:float -> to_factor:float -> t -> unit

  val reflat : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit
  (** Adjust an existing layout to arrange its rooms in a "flat" fashion, as if
     they were created by {!Layout.flat}. Will be animated if [duration <> 0]. *)

  val retower : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit

  (** {2 Windows}

      An SDL window is created for each Layout in the list sent to
     {!Main.create}.  *)

  val window_opt : t -> Tsdl.Sdl.window option
  (** Return the SDL window containing the layout. It will return [None] if the
     window was not created yet, or was previously destroyed. Note that SDL
     windows are created by {!Main.run}, not before. *)

  val show_window : t -> unit
  (** Make the window containing the layout appear onscreen, using [set_show]
     and [Sdl.show_window]. (If the layout was hidden at startup,
     [Sdl.show_window] is not enough to display the layout: use this function
     instead.) *)

  val hide_window : t -> unit
  (** Hide the window containing the layout. *)

  val set_window_pos : t -> int * int -> unit
  (** [set_window_pos layout x y] sets the position of the window containing
     [layout] to (x,y), in physical pixels. (0,0) is top-left. This should be
     run {b after} {!Main.create}.  *)

  val get_window_pos : t -> int option * int option
  (** Return the window position within the desktop, in physical pixels. *)

  val push_close : t -> unit
  (** Emit the close-window event to the window containing the layout, as if the
     user clicked on the close button. This should close the window at the next
     graphics frame, or execute the function registered by
     {!Window.on_close}. *)

  val destroy_window : t -> unit
  (** Emit the destroy_window event to ask Bogue to destroy the SDL window
      containing the layout. *)

  (** {2 Misc} *)

  val inside : t -> int * int -> bool

  val claim_keyboard_focus : t -> unit

  val set_cursor : t option -> unit
  (** Set the current cursor to the default value for this layout. *)

  (** Search for the room containing the widget, if any. *)
  val containing_widget : Widget.t -> t option

end (* of Layout *)

(* ---------------------------------------------------------------------------- *)

(** Adjust various spacing and sizes of layouts.

These functions {e do not take effect immediately!} They will be executed, in
   the order of their invocation, at the next graphics frame (or at startup if
   they are invoked before the start of the mainloop).

{5 {{:graph-dot-b_space.html}Dependency graph}}
 *)
module Space : sig

  val hfill : ?right_margin:int -> unit -> Layout.t
      (** When used in a {!Layout.flat} structure, this special empty layout will
     automatically expand in order to fill the available width in the parent
     house. The other inhabitants keep the width they had at the execution of
     the [hfill] invocation. Their height is resized as usual. Only one [hfill]
     layout should be used in a given house. *)


  val make_hfill : ?right_margin:int -> Layout.t -> unit
  val full_width : ?right_margin:int -> ?left_margin:int -> Layout.t -> unit
     (** This will set the width of the room (layout) in order to occupy the whole
     width of its house. *)

  val make_vfill : ?bottom_margin:int -> Layout.t -> unit
 (** Like {!hfill}, but applies to the specified layout instead of creating an
      empty one. *)

  val vfill : ?bottom_margin:int -> unit -> Layout.t
    (** When used in a {!Layout.tower} structure, this special empty layout will
     automatically expand in order to fill the available height in the parent
     house. See {!hfill}. *)

  val full_height : ?top_margin:int -> ?bottom_margin:int -> Layout.t -> unit

  val keep_bottom : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit

  val keep_right : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit


end (* of Space *)

(* ---------------------------------------------------------------------------- *)

(** Convert Bogue objects to strings for debugging.

    {5 {{:graph-dot-b_print.html}Dependency graph}}
*)
module Print : sig

  val layout_down : ?indent:string -> Layout.t -> string
  (** Print a layout with all its rooms and subrooms (children). *)

  val layout_up : ?indent:string -> Layout.t -> string
  (** Print the layout node and all the rooms (houses, or parents) in which it
      is contained. *)

  val layout_error : Layout.t -> string -> unit
  (** Print a message to stderr and dump the top_house structure to a temporary
     file. *)

end (* of Print *)

(* ---------------------------------------------------------------------------- *)

(** Create an image from a Layout.

{5 {{:graph-dot-b_snapshot.html}Dependency graph}}
*)
module Snapshot : sig

  val create : ?border:Style.border -> Layout.t -> Widget.t
  (** Should be called from the main thread only. There are some issues with
     transparency.
      @return a Box widget. *)

  val to_cursor : ?hot_x:int ->
    ?hot_y:int -> Layout.t -> Tsdl.Sdl.cursor option

end (* of Snapshot *)

(* ---------------------------------------------------------------------------- *)

(** {2 Predefined Layouts}

    These modules help you create commonly used layouts: lists, menus, etc.

 *)

(** Add a validator to a Text_input


    A validator is a small icon, located next to a Text entry, indicating
    whether the text typed by the user is "valid" under certain rules (for
    instance, a valid email address). In strict mode, the validator can also
    completely prevent the user from typing any invalid string.

{5 {{:graph-dot-b_ti_validate.html}Dependency graph}}
*)
module Ti_validate : sig
  type t

  type status = bool option
  (** String status:
 + Some true = good text
 + Some false = bad text
 + None = undecided yet
  *)

type validator = string -> status * string option
(** A validator function takes a string that the user has typed in the
    Text_input widget, and returns:
    + the status: "is this string valid?"
    + optionally, the string that should be entered instead. None means: keep
    the user entry.
*)

val get_status : t -> status
val get_layout : t -> Layout.t
val get_text_input : t -> Widget.t
val get_text : t -> string

val regexp_validator : ?strict:bool -> string -> validator
(** Construct a validator function from a regular expression. If [strîct] is
    true, the complete string must match the complete regular expression to
    validate. Only valid text is allowed (so make sure that the default string
    does validate!)

    If [strict=false], the status stays "undecided" as long as the whole string
    is a prefix of a potential string that would strictly match. Thus, the user
    is allowed to type strings that are "not complete yet".

        @see "Example #58".
*)

val make : validator -> ?bg:Draw.rgb -> ?prompt:string -> ?size:int ->
  string -> t
(** Return a layout containing a Text Entry and a Validity indicator; also
    return a function to examine the validity of the last user entry. *)

val of_regexp : ?strict:bool -> string -> ?bg:Draw.rgb ->
  ?prompt:string -> ?size:int -> string -> t
(** Same as {!make}, with a validator obtained from a regular expression via
    {!regexp_validator}. *)


(** Implement email validation following
    {{:https://html.spec.whatwg.org/multipage/input.html#email-state-(type=email)}HTML
    specs}.

    @see "Example #59".
*)
module Email : sig
  val validator : validator
  val is_valid : string -> bool
  (** [is_valid addr] is true when (and only when) [addr] is a valid email
      address according to the HTML specs. *)

  val hint : string -> string
  (** [hint addr] returns a message explaining why [addr] might not be a valid
      email address.*)
  end
end (* of Ti_validate *)


(** Handle large lists by not displaying all elements at once.

Very quickly, displaying a list of layouts (for instance, listing files in a
   directory) can run the computer out of memory if it tries to keep in memory
   the textures of {b all} entries of the list. In these cases you need to use a
   [Long_list].

    See for instance {b Example #34} that displays a list of 1 million entries.

    Long_lists may contain any type of Layout. They don't need to be all of the
    same dimension. Instead of providing the list of layouts, one must give a
    function [generate] such that the layout given by [generate i] is the i-eth
    element of the list.

{5 {{:graph-dot-b_long_list.html}Dependency graph}} *)
module Long_list : sig
  type t

  val create : ?name:string ->
    w:int -> h:int -> length:int -> ?first:int ->
    generate:(int -> Layout.t) ->
    ?height_fn:(int -> int option) ->
    ?cleanup:(Layout.t -> unit) ->
    ?max_memory:int ->
    ?linear:bool -> ?scrollbar_width:int -> ?scale_width:bool -> unit -> t
  (** Create a long list through the function [generate] which maps any index {e i}
      to the {e ieth} element (layout) of the list. If specified (which is
      not a good idea), the [max_memory] should be at least twice the area (in
      physical pixels) of the visible part of the list. If the number of
      elements is large (typically 100000 or more, this depends on your CPU),
      its is highly advisable to provide a [height_fn], which to an index {e i}
      gives the height (in logical pixels) of the {e ieth} entry. If some
      heights are not known in advance, it's ok to return [None]. For instance,
      if all entries have the same height, say 30 pixels, one can define

      {[ let height_fn _ = Some 30 ]} *)

  val create_layout : ?name:string ->
    w:int -> h:int -> length:int -> ?first:int ->
    generate:(int -> Layout.t) ->
    ?height_fn:(int -> int option) ->
    ?cleanup:(Layout.t -> unit) ->
    ?max_memory:int ->
    ?linear:bool -> ?scrollbar_width:int -> ?scale_width:bool -> unit -> Layout.t
  (** Similar to [create] but only returns the layout. Equivalent to calling
      {!get_layout} to the result of [create]. *)

  val get_layout : t -> Layout.t
  val get_scroll : t -> float
  (** Return the scroll percentage of the Long list, between 0 and 1. A value of
      0 means no scroll: the first row is visible. The value 1 means that the
      scrollbar is fully downwards, the last row is visible. *)

  val set_scroll : t -> float -> unit

end (* of Long_list *)

(* ---------------------------------------------------------------------------- *)

(** Switch between layouts using Tabs.

{5 {{:graph-dot-b_tabs.html}Dependency graph}}
*)
module Tabs : sig

  val create :
    ?slide:Avar.direction ->
    ?adjust:Layout.adjust -> ?expand:bool ->
    ?canvas:Draw.canvas ->
    ?name:string -> (string * Layout.t) list -> Layout.t
end (* of Tabs *)

(* ---------------------------------------------------------------------------- *)

(** Various types of menus.

The generic {!create} function produces menus whose entries can be arbitrary
   layouts located at arbitrary places. But for usual text entries, it is enough
   to provide a string for the entry label, and the layout will be constructed
   automatically.

The specialized {!bar} function will produce a familiar menu bar with drop-down
   submenus.

{5 {{:graph-dot-b_menu.html}Dependency graph}}
*)
module Menu : sig

  type t
  (* The type of generic menus. *)

  type action = unit -> unit

  type label =
    | Text of string
    | Layout of Layout.t

  type entry = {
      label : label;
      content : content }

  and content =
    | Action of action
    | Flat of entry list
    (** A Flat content will produce a horizontal menu *)
    | Tower of entry list
    (** A Tower content will produce a vertical menu *)
    | Custom of entry list
    (** In a Custom content, only Layout labels should be used, and their
       position should be defined before creating the menu. *)
    | Separator
    (** Currently only used for inserting separator lines in Tower menus. *)

  val create : ?dst:Layout.t -> content -> t
(** Generic menu creation, inserted in the [dst] layout. *)

  val add_bar : dst:Layout.t -> entry list -> unit
  (** Creation of a menu bar in the [dst] layout, with drop-down submenus.
      [bar dst entries] inserts a layout which contains the menu bar into the top of
      the [dst] layout (so, some room should be provided). The [dst] layout
      should be big enough to contain the submenus. Any item flowing out of [dst]
      will not get focus. *)

  val bar : entry list -> Layout.t
  (** Return a menu layout that will be installed with {!add_bar} into the top
     house at startup. *)

  val separator : entry

end

(* ---------------------------------------------------------------------------- *)

(** Drop-down select list.

    It's the usual select box which opens a drop-down list when clicked on,
    similar to the [<select>] html tag.

    Under the hood, a select list is a special type of menu with a single entry
    having a submenu.

    @see "Example #28".

    {%html:<div class="figure" style="text-align:center"><img
    src="images/example28.webp" srcset="images/example28.webp 2x"></div>%}

{5 {{:graph-dot-b_select.html}Dependency graph}} *)
module Select : sig

  val create : ?dst:Layout.t ->
    ?name:string ->
    ?action:(int -> unit) ->
    ?fg:Draw.color ->
      string array -> int -> Layout.t
  (** [create string_array i] creates a select box with preselected entry
     [i]. For instance [create [| "A"; "B"; "C" |] 1] will create a select box
     with default choice ["B"]. The [action] (if specified) is executed when an
     item is selected, and takes as argument the index of the selected item.

        @return a layout showing the selected item. *)

end (* of Select *)

(* ---------------------------------------------------------------------------- *)

(** Check list with a single choice.

    Each item of the list is displayed with a 'radio button' in front of it, and
    at most one item can be selected, similarly to [<input type="radio"...>] in
    html. Radiobuttons are implemented with {!Check.t}.

    @see "Example #29".

    {%html:<div class="figure" style="text-align:center"><img
    src="images/example29.png"></div>%}


{5 {{:graph-dot-b_radiolist.html}Dependency graph}}
*)
module Radiolist : sig
  type t

  val vertical : ?name:string -> ?click_on_label:bool -> ?selected:int ->
    string array -> t
  (** A radiolist with the usual vertical layout of items. The option
      [click_on_label] is true be default: one can click on the label to select
      it. *)

  val of_widgets : ?selected:int -> Widget.t list -> t

  val layout : t -> Layout.t
  (** The layout to display the radiolist. *)

  val get_index : t -> int option
  val set_index : t -> int option -> unit
  (** Set the selected entry to the specified index and directly activate the
     button's connections with the {!Trigger.var_changed} event. *)

  val active_widgets : t -> Widget.t list
  (** @return the list of widgets that are active for selecting entries ({e
     i.e.} either radiobuttons or radiobuttons and labels, depending on
     [click_on_label]. *)
end (* of Radiolist *)

(* ---------------------------------------------------------------------------- *)

(** Tables with sortable columns and selectable rows.

    This module helps you create multi-column tables. You just need to provide
    the contents of each row.

    - Click on the column title to {b sort} the table with respect to this column.
    - Click on a row to {b select} or {b unselect} it.
    - After clicking on a row, hit CTRL-A to select {b all rows} at once.
    - After clicking a row, click on another row with SHIFT pressed to select
      {b a range of rows}.
    - One can limit the maximum number of selected rows.
    - Actions can be executed when a row is clicked on.

    Tables internally use a {!Long_list} and hence will nicely handle a very
    large number of rows. A vertical scrollbar will appear as soon as the whole
    table height does not fit in the layout. However, contrary to Long_lists, in
    a table all rows must have the same height.

    {%html:<div class="figure" style="text-align:center"><img
    src="images/example35.png"><br> A three-column table (plus two buttons)
    (Example #35)</div>%}

{5 {{:graph-dot-b_table.html}Dependency graph}}
*)
module Table : sig
  type column =
    { title : string;
      length : int; (** number of entries in the column. *)
      rows : int -> Layout.t;
      (** [row i] should return the Layout corresponding to the ieth entry of
          that column. *)
      compare : (int -> int -> int) option;
      (** if a compare function is provided, then the column will be dynamically
          sortable by the user. [compare i1 i2 > 0] means that entry [i1] is
          larger than entry [i2]. *)
      min_width : int option; (** pixel width of the column. If not specified,
                                  the max width of the first 50 entries will be
                                  used. *)
      align : Draw.align option
    }
  type t

  val create : h:int -> ?row_height:int -> ?name:string ->
    ?on_click:(t -> int -> unit) ->
    ?max_selected:int -> ?selection:Selection.t ->
    ?on_select:(Selection.t -> unit) -> column list -> t
  (** Create a table by specifying its list of {b columns}; in each column, the
      entries can be arbitrary layouts. If entries are simple text labels, it's
      easier to use the helper functions {!of_array} or {!of_list}. If
      [row_height] is not specified, the height of the first row is used
      instead. The width of the table is determined by the [min_width] column
      parameters.

      Some rows can be initially selected by providing the [selection] argument.

      The function [on_select] is executed each time the selection is
      modified. Its argument is the new selection. This function is executed {e
      before} the new selection is recorded in the table variable (of type [t]).

      Everytime a row is clicked, the [on_click] function is called with two
      arguments: the table itself and the index of the row. (The first row has
      index 0.
      )
      @see "Example #35". *)

  val of_array :
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string -> ?on_click:(t -> int -> unit) ->
    ?max_selected:int -> ?selection:Selection.t ->
    ?on_select:(Selection.t -> unit) -> ?align:Draw.align ->
    string list ->
    string array array -> t
  (** Create a table from an array of {b rows}, each row being a string
      array.

      @see "Example #35bis". *)

  val of_list :
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string -> ?max_selected:int ->
    ?selection:Selection.t -> ?on_select:(Selection.t -> unit) ->
    ?align:Draw.align ->
    string list list -> t
    (** Create a table from a list of {b rows}, each row being a string list.

       @see "Example #35ter". *)

  val get_layout : t -> Layout.t
  (** Use this layout to display your table. *)

  val get_selection : t -> Selection.t
  (**  Which rows were selected by the user. *)

  val set_selection : t -> Selection.t -> unit
  val sort_column : t -> ?reverse:bool -> int -> unit
  val min_width : t -> int
  (** Hint for minimum width of the table layout; it's up to the user to
      enforce this. *)

  val min_height : t -> int
    (** Same remark. *)
end (* of Table *)

(**
   [ module ]{!File}[ ] : file chooser and file monitor *)

(* ---------------------------------------------------------------------------- *)

(** {2 Opening windows and running your app with the Bogue mainloop}

    Because a GUI continuously waits for user interaction, everything has to run
    inside a loop. You open your GUI window(s) and start the loop with
    {!Main.run}, and this is usually the last command of your Bogue code.  *)

(* ---------------------------------------------------------------------------- *)

(** Windows

    In order to display a Layout, Bogue needs to create a {!Window.t} for it,
    and pass it as argument of {!Main.create}. This is done automatically if you
    use {!Main.of_layouts}, so most of the time you don't need to deal with
    {!Window.t}'s.

    Ultimately, "physical" windows are created by SDL, and hence will appear
    with the usual decorations of your Desktop Environment.

    {5 {{:graph-dot-b_window.html}Dependency graph}}
*)
module Window : sig
  type t
  val create : ?on_close:(t -> unit) -> Layout.t -> t
  (** Create a window from the given layout. The layout must not belong to any
      room. If the layout is hidden, the window will be created but not shown.

      @param on_close Set the function to be executed when the user wants to
        close the window. By default, the window will be destroyed. Hence,
        setting a function can prevent the window from being closed. However, if
        this is the sole open window, clicking on the close button will also
        emit the 'Quit' event, and will terminate Bogue anyways.

      @see "Example #11". *)

  val on_close : t -> (t -> unit) option -> unit
  (** Modify the [on_close] parameter of {!create}. *)

  val destroy : t -> unit
  (** Ask Bogue to destroy the window. *)

  val set_size : w:int -> h:int -> t -> unit
  (** Set window size in physical pixels. Only works after the window is
      physically created by {!Main.run}. However, you may use [set_size] in
      advance with {!Sync.push}. *)

  val maximize_width : t -> unit
  (** See remarks in {!set_size}. *)

end (* of Windows *)

(* ---------------------------------------------------------------------------- *)

(** Control the workflow of the GUI mainloop.

{5 {{:graph-dot-b_main.html}Dependency graph}}
*)
module Main : sig
  type board
  (** The board is the whole universe of your GUI. It contains everything.  Most
      of the time, though, you don't really care, because you will immediately
      run your board after creating it, like in [run (of_layout my_layout)].

      However, nothing prevents you from creating several boards and finally
      choosing the one you want to run. What you should {e not} do is to
      simultaneously run several boards in different threads, because SDL can
      manage events only from the main thread. *)

  type shortcuts
    (** Shortcut maps can be passed to the board to associate an arbitrary
        action with specific keys (like quitting when ESC is pressed). See
        {!shortcuts_}. *)

  exception Exit
  (** Raising the [Exit] exception will tell the GUI loop to terminate. *)

  val create : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Window.t list -> board
  (** Create a [board] from a list of layouts and connections. The list of
      connections can be empty, because connections can be added
      afterwards. Each Layout in the list will open as a new window.

      @param shortcuts This optional argument is a {%html:<a
        href="#shortcuts_">shortcut map</a>%}.

      @param on_user_event This optional argument is a function to be executed
        (by the main thread) when a {!Trigger.user_event} is emitted.
  *)

  val get_monitor_refresh_rate: board -> int option
  (** [get_monitor_refresh_rate board] returns the monitor refresh rate, for the
      monitor containing [board]. In case of several monitors with different
      refresh rates, return the greatest common divisor, or the minimum if the
      gcd is less than 30. *)

  val of_windows :  ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Window.t list -> board
  (** Synonym for {!create}. (Since 20220418) *)

  val of_layouts : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Layout.t list -> board
  (** Similar to {!create}. Each layout in the list will be displayed in a
     different window. (Since 20220418) *)

  val of_layout : ?shortcuts:shortcuts ->
    ?connections:(Widget.connection list) ->
    ?on_user_event:(Tsdl.Sdl.event -> unit) -> Layout.t -> board
  (** Similar to {!of_layout} but with only one layout. (Since 20220418) *)

  val make : ?shortcuts:shortcuts ->
    (Widget.connection list) -> Layout.t list -> board
  (** Similar to {!of_layouts}.

     @deprecated   (since 20220418). Use {!of_layouts} or {!create} instead. *)

  val run :
    ?vsync:bool ->
    ?before_display:(unit -> unit) ->
    ?after_display:(unit -> unit) -> board -> unit
  (** This is finally how you run your app! It creates the SDL windows
     associated with the {!Window.t}s registered with the board, and launches
     the main loop. This function only returns when all windows are closed (in
     case at least one window was created), or when the {!Exit} exception is
     raised.
    [vsync] defaults to [true] and enables synchronization to monitor refresh rate
    where possible, otherwise a 60 FPS {!Time.adaptive_fps} is used.
    *)

  (** {3:shortcuts_ Creating global keyboard shortcuts}

      A shortcut consists of two integers: one for the
      {{:https://erratique.ch/software/tsdl/doc/Tsdl/Sdl/Kmod/index.html}key
      modifier} (shift, ctrl, etc.) and one for the key code (from
      {{:https://erratique.ch/software/tsdl/doc/Tsdl/Sdl/K/index.html}SDL
      table}), plus an action to be executed when this key combination is
      pressed.

      For the shortcuts to take effect, one has to pass a [shortcuts] argument
      to the board creating functions. This argument can be created with
      [shortcuts_of_list], or by using the [shortcuts_add*] functions below. *)

  type shortcut_action = board -> unit

  val shortcuts_of_list :
    (Tsdl.Sdl.keymod * Tsdl.Sdl.keycode * shortcut_action) list -> shortcuts
  (** Construct shortcuts from a list of (SDL keycode, SDL keymod, action). *)

  val exit_on_escape : Tsdl.Sdl.keymod * Tsdl.Sdl.keycode * shortcut_action
  (** The [exit_on_escape] shortcut will raise the {!Exit} exception upon
      pressing the Escape key.

      @see "Example #6". *)

  val shortcuts_empty : unit -> shortcuts

  val shortcuts_add : shortcuts ->
    ?keymod:Tsdl.Sdl.keymod -> Tsdl.Sdl.keycode -> shortcut_action -> shortcuts

  val shortcuts_add_ctrl : shortcuts  -> Tsdl.Sdl.keycode -> shortcut_action ->
    shortcuts

  val shortcuts_add_ctrl_shift : shortcuts -> Tsdl.Sdl.keycode -> shortcut_action ->
    shortcuts

  val get_shortcut : ?map:shortcuts -> ?keymod:Tsdl.Sdl.keymod -> int ->
    shortcut_action option

  val remove_shortcut : ?board:board -> ?keymod:Tsdl.Sdl.keymod -> int -> unit

  val add_shortcut: ?board:board ->
    ?keymod:Tsdl.Sdl.keymod -> int -> shortcut_action -> unit

  (** {2 Using Bogue together with another graphics loop}

      See the [embed] example. *)

  val make_sdl_windows : ?windows:Tsdl.Sdl.window list -> board -> unit
  (** This is only useful if you have your own graphics loop, and do {e not} use
      {!run}. This function creates an SDL window for each top layout in the
      board. One can use predefined windows with the optional argument
      [windows]. They will be host the layouts in the order they appear in the
      list. If there are fewer windows than layouts, new windows are created. If
      there are more, the excess is disregarded. *)

  val refresh_custom_windows : board -> unit
  (** Ask the GUI to refresh (ie. repaint) the custom windows (those that were
      not created by Bogue itself). *)

  val one_step : ?before_display:(unit -> unit) ->
    bool -> (unit -> unit) * (unit -> unit) -> ?clear:bool -> board -> bool
  (** This is only useful if you have your own graphics loop, and do {e not} use
      {!run}. Calling [one_step ~before_display anim (start_fps, fps) ~clear
      board] is what is executed at each step of the Bogue mainloop. If
      [anim=true] this step is {e non blocking}; this is what you want if either
      Bogue or your loop has an animation running. If [anim=false] then the
      function will wait until an event is received.

      @return [true] if the GUI currently handles an animation. In this case
      [fps()] was executed by [one_step]. If not, you should handle the frame rate
      yourself. *)

  val get_frame : unit -> int
  (** Number of displayed frames since startup. *)

  val quit : unit -> unit
  (** Use this to close SDL windows and cleanup memory, after {!run} has
      returned. This does not exit your program. Calling [quit ()] is not
      necessary if your program exits after {!run}.*)

end (* of Main *)

(* ---------------------------------------------------------------------------- *)

(** Alias for {!Main} *)
module Bogue = Main

(**/**)
val run_tests : unit -> unit
(**/**)


(* ---------------------------------------------------------------------------- *)

(** Put layouts on top of others, or in new windows.

    This module provides usual modal popups like "info" boxes or "yes/no" popups.

    Internally, popups are layouts inserted in a destination layout, but
    belonging to a different {e layer}, which ensures that they are drawn on top
    of the destination layout.

    {e Warning:} For all functions in this module, the destination layout must
    be a house, not a single resident. (This means that the layout's
    {!Layout.room_content} must not be a [Resident].)

    When the [dst] destination parameter is optional, and if it is not provided,
    then the popup will be created in a {e separate new window}.

        {%html:<div class="figure" style="text-align:center"><img
        src="images/example21bis.png"><br> A simple modal popup with a single
        button (Example #21bis)</div>%}

    Popups can (optionally) be closed by pressing ESCAPE (even if ESCAPE is used
    for another action in the main application, see Example 21bis).

    Popups are also used to display {{!tooltips_}tooltips}.

{5 {{:graph-dot-b_popup.html}Dependency graph}} *)
module Popup : sig

  (** {2 Generic functions}

      These functions allow you to craft your own popups, when the predefined
      ones below are not enough. See Example #21. *)

  val add_screen : ?color:Draw.color -> Layout.t -> Layout.t
  (** Add a screen on top of the layout. This can be useful to make the whole
      layout clickable as a whole.
      @return the screen. *)

  (** Generic modal type popup *)
  val attach : ?bg:Draw.color ->
    ?show:bool -> Layout.t -> Layout.t -> Layout.t
  (** [attach house layout] adds two layers on top of the house: one for the
     screen to hide the house, one for the layout on top of the screen.
     @return the screen. *)

  (** {2 Predefined popups}

  *)

  val info : ?w:int -> ?h:int -> ?button_w:int -> ?button_h:int ->
    ?button:string -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with a text and a close button. By
      default, [button="Close"] (or, rather, the translation of "Close" into the
      user local language). This popup can be closed by pressing ESCAPE. Use the
      optional parameters [button_w, button_h] to impose the size of the
      button. The optional parameters [w] and [h] set the width and height of
      the popup (including the button) by scaling the computed layout. If they
      are too small, the text might not be fully legible. *)

  val yesno : ?w:int -> ?h:int -> ?button_w:int -> ?button_h:int ->
    ?yes:string -> ?no:string ->
    yes_action:(unit -> unit) ->
    no_action:(unit -> unit) -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with two yes/no buttons. By default,
      [yes="Yes"] and [no="No"] (localized). This popup is {e not} closed by
      pressing ESCAPE. See {!info} for other common parameters. *)

  val one_button : ?w:int -> ?h:int -> ?bg:Style.background ->
    ?on_close:(unit -> unit) -> button:string -> dst:Layout.t ->
    ?close_on_escape:bool -> Layout.t -> unit
  (** Add to [dst] the given layout and one button with the [button]
      string. Clicking the button will close the popup and execute the optional
      [on_close] function. *)

  val two_buttons : ?dst:Layout.t -> ?board:Main.board ->
    ?button_w:int -> ?button_h:int ->
    ?w:int -> ?h:int -> ?bg:Style.background -> ?screen_color:Draw.color ->
    label1:string -> label2:string ->
    action1:(unit -> unit) -> action2:(unit -> unit) -> ?connect2:(Widget.t -> unit) ->
    ?close_on_escape:bool -> Layout.t -> unit
  (** If [dst] is present, a popup containing the given layout (and two buttons)
      will be contructed inside [dst], otherwise a new window will be
      created. In the latter case, the creation of the new window depends on the
      [board] argument. If the [board] argument is provided, the new window will
      be immediately attached to the board; otherwise, the new window will be
      created (by the main thread) when the board is running, at the start of
      the next frame. The [board] argument has no effect if [dst] is provided.

      The optional function [connect2] will be immediately called with the
      second button widget as argument. It can be used to establish a connection
      to or from the second button. For instance, one can use this to disable
      the button if some condition is not met. (This is used for instance in
      {!File.select_file}.) *)


  (** {2:tooltips_ Tooltips}

      Tooltips are informative pieces of text that show up when the pointer
      stays idle for a moment over a given widget.

      See Example #44.

      {%html:<div class="figure" style="text-align:center"><img
        src="images/example44.png"><br> A button with a tooltip (Example #44)</div>%}

  *)

  type position =
  | LeftOf
  | RightOf
  | Above
  | Below
  | Mouse

  val tooltip : ?background:Layout.background ->
    ?position:position ->
    string -> target:Layout.t -> Widget.t -> Layout.t -> unit
  (** [tooltip text ~target widget layout] adds a tooltip which will appear on
     [layout], next to [target] (which should be a sublayout of [layout]), when
     the [widget] gets mouse focus and mouse is idle for some time on it. A
     tooltip it not a modal popup, it does not prevent from interacting with the
     rest of the layout. *)

end (* of Popup *)

(* ---------------------------------------------------------------------------- *)

(** File dialog and file monitor

    This module offers a quite complete file dialog layout.

    - The dialog opens either in a {b new window}, or as a {!Popup} on top of any
    existing layout. It can also be inserted anywhere just like any other
    layout.
    - One can choose to select only {b files} or {b directories}.
    - One can optionally limit the number of selected files.
    - The file system is {b monitored} so that changes in the currently opened
    directory are automatically taken into account.
    - One can easily open huge directories with thousands of files.
    - The file system can be easily {b navigated} by either clicking on the children
    directories, or entering manually the requested path, or clicking on parents
    directories in a special breadcrumb layout.
    - The whole layout is resizable by the user.
    - The dialog can be closed by pressing ESCAPE
    (even if ESCAPE is used for another action in the main application).

    {b Warning: } Some {!options} are not implemented yet; these -- and more
    features -- will certainly be added in the future.

    {%html:<div class="figure" style="text-align:center"><img src="images/file_dialog.png"><br>
    File dialog in a separate window</div>%}

    @see "Example #54".

    {5 {{:graph-dot-b_file.html}Dependency graph}}
*)
module File : sig

  (** Monitoring changes in a directory.

      This module provides functions for watching for changes in a directory (or
      a single file), and executing arbitrary actions when a change is detected.

      All functions are non-blocking and return very fast, even if the path is
      remote or the directory is huge. To achieve this, monitoring is done in a
      separate thread and one has to accept a delay before actual changes to the
      file-system are reported.

      We provide two implementations, one is based on the external
      {{:https://emcrisostomo.github.io/fswatch/}fswatch} program, and the other
      is based on the built-in Ocaml function [Unix.stat]. The [fswatch]
      implementation is automatically chosen by default if the [fswatch]
      executable is detected. Otherwise, the [Unix.stat] fallback is used (which
      is maybe more memory and cpu intensive). *)
  module Monitor : sig
    type t
    val path : t -> string
    (** Return the monitored path.*)

    val start : ?delay:float -> ?action:(t -> unit) -> string -> t
    (** [start path] starts monitoring the directory or file [path] and
        immediately returns. It is not an error if [path] does not exist or is
        eventually deleted, see below. Once monitoring has started, check the
        {!modified} function below to obtain the actual changes.

        @param delay the time interval (in seconds) between polls.  The default
          delay is 1 second. It may be internally increased if the polls take
          too much time.

        @param action executed for each modification. Note that false positive
          may happen; hence the action should be fast and non blocking
          (typically just sending an event).

 *)

    (* Thus, what we call "current" will actually mean "not older than
       delay". *)
    val delay : t -> float
    (** Return the delay (in seconds) between two polls. *)

    val stop : t -> unit
    (** Kill the monitoring process. *)

    val ls : t -> string list
    (** [ls m] returns the list of files watched by the monitor [ m ] when the
        last [*modified] function was called. {e Thus, it may be different from
        the actual current content.} If [ m ] monitors a directory, [ls m] is
        the content of the directory (without "." and ".."), otherwise [ls m] is
        [["."]] if the file exists, or [[]] if not. This function takes
        advantage of the monitoring data to return faster (in general) than
        rescanning the directory with [Sys.readdir]. The order of the list is
        not specified (although for the [fswatch] implementation it should be
        sorted by increasing alphabetical order.) *)

    val size : t -> int option
    (** If [t] monitors a directory, then [size t] is the number of elements of
        this directory, before recent modifications. Otherwise, [size t] returns
        None. Calling [size t] is equivalent to but faster than
        [List.length (ls t)]. *)

    val modified : t -> string list * string list * string list
    (** Return three lists of file (or directory) names that have been modified
        since last call of this function or of [was_modified]:

        {e list of deleted elements, list of added elements, list of modified elements}

         Lists are not sorted (except when using the [fswatch]
         implementation). File names do not include the directory path. These
         lists can be equal to the singleton [["."]] in some special cases:

        + if the [path] now exists but did not exist in the previous call to
        [*modified], then the [added] list is [["."]] and the others are empty (even
        if some contents of [path] were modified in the meantime: remember that we
        only compare to the previous call to [*modified].)
        + if the [path] existed in the previous call to [*modified] but not
        anymore, then the [deleted] list is [["."]] and the others are empty.
        + if the [path] existed in the previous call to [*modified], then has
        disappeared and then reappeared again, the [modified] function will return
        [[], ["."], []] instead of the explicit difference, telling you that it is
        safer to read the contents again (using [ls] for instance). *)

    val was_modified : t -> bool
    (** Simply returns true if files were modified since the last call of this
        function or of [modified]. The list of modified files cannot be
        retrieved. This is (semantically) equivalent to checking if the lists
        returned by [modified] are not all empty, but possibly faster. *)
  end (* of Monitor *)

  (** Mimetype information *)
  module Mime : sig
    val type_string : string -> string
    (** [type_string filename] returns the mimetype string of [filename],
        obtained by inspecting only the [filename] extension (no inspection of
        the file is done), using this
        {{:https://raw.githubusercontent.com/sanette/bogue/refs/heads/master/lib/ext2mime_data.ml}table}. For
        instance: ["image/png"].

        The function returns [""] if no mimetype is found. *)

  end(* of Mime *)

  type t (** The type for file dialogs. *)

  type options

  val set_options :
    ?width:int -> ?height:int ->
    ?dirs_first:bool ->
    ?show_hidden:bool ->
    ?hide_backup:bool ->
    ?max_selected:int ->
    ?hide_dirs:bool ->
    ?only_dirs:bool ->
    ?select_dir:bool ->
    ?allow_new:bool ->
    ?default_name:string ->
    ?breadcrumb:bool ->
    ?system_icons:bool ->
    ?open_dirs_on_click:bool ->
    ?mimetype:Str.regexp ->
    ?on_select:(int * int -> unit) -> unit -> options
  (** @param dirs_first partially implemented
      @param system_icons not implemented
  *)

  type entry (** The [entry] type can be used to create filters for selecting
                 what is actually displayed by the file dialog. *)

  val filename : entry -> string
  val lstat_opt : entry -> Unix.stats option
  val stat_opt : entry -> Unix.stats option
  (** The [stat_opt] and [lstat_opt] return the corresponding pre-computed
      [Unix.stats] results, without actually calling any system function.  *)

  val dialog : ?full_filter:(entry -> bool) -> ?options:options -> string -> t
  (** Use this function if you need unusual combinations of options. For most
      common uses, see {!select_file} (and others) below. *)

  val get_layout : t -> Layout.t
  (** Return the layout containing the whole file dialog except for the "select"
      and "cancel" buttons. *)

  val get_selected : t -> string list
  (** Return the (alphabetically sorted) list of selected files or
      directories. *)

  val basedir : t -> string
  (** Return the full path of the currently displayed directory. *)

  val select_file : ?dst:Layout.t -> ?board:Main.board ->
    ?w:int -> ?h:int -> ?mimetype:Str.regexp -> ?name:string ->
    string -> (string -> unit) -> unit
  (**  [select_file dirname continue] will open a file dialog, initially showing
       the content of the directory [dirname]. The user can then navigate to
       other directories. When the user selects a file in the list and presses
       the "Select file" button, the dialog will close, and the [continue]
       function will be applied to the selected filename (full path).

       If the dialog is closed by the user pressing the "Cancel" button or the
       ESCAPE key, the [continue] function is not used.

       Note that global bindings to the ESCAPE key are temporarily disabled when
       the file dialog is open.

      @param dst the file selector will show up on top of the [dst] layout, or
        in a new window if [dst] is not provided.

      @param mimetype only show files whose mimetype string (like "image/png")
        matches the regular expression.

      @param board See {!Popup.two_buttons}. Note that, if [board] is omitted,
        the window will be created at the next frame, but the file selector
        layout is immediately created.

      @param name default name to be chosen.

      @see "Example #54".
  *)

  val select_files : ?dst:Layout.t -> ?board:Main.board ->
    ?w:int -> ?h:int -> ?mimetype:Str.regexp ->
    ?n_files:int -> string -> (string list -> unit) -> unit
  (** Similar to {!select_file} except that here several files can be
      selected. If [n_files] is provided, it will be the maximum number of files
      that may be selected. *)

  val select_dir : ?dst:Layout.t -> ?board:Main.board ->
    ?w:int -> ?h:int -> ?name:string -> string -> (string -> unit) -> unit
  (** Similar to {!select_file} except that here only a directory can be
      selected. If the user clicks on a directory name, they will be given the
      option to either open this directory (for further navigation), or select
      it (hence closing the dialog).  *)

  val select_dirs : ?dst:Layout.t -> ?board:Main.board ->
    ?w:int -> ?h:int -> ?n_dirs:int -> string -> (string list -> unit) -> unit
  (** Similar to {!select_files} except that here only directories can be
      selected. *)

  val save_as : ?dst:Layout.t -> ?board:Main.board ->
    ?w:int -> ?h:int -> ?name:string -> string -> (string -> unit) -> unit
  (** Similar to {!select_file}, but here the user can enter a filename that
      does not already exist in the displayed directory.  *)

  val ( let@ ) : ('a -> 'b) -> 'a -> 'b
  (** [ ( let@ ) f x ] is just [ f x ]. You can use this "syntaxic sugar"
      to write your code like this:
          {[
let open File in
let@ file = select_file "/tmp" in
print_endline ("Selected file : " ^ file)]} instead of
          {[
File.select_file "/tmp" (fun file ->
    print_endline ("Selected file : " ^ file))]}
      *)

end (* of File *)

(* ---------------------------------------------------------------------------- *)

(** {2:example Example}

    Here is a minimal example with a label and a check box.

{[open Bogue
module W = Widget
module L = Layout

let main () =

  let b = W.check_box () in
  let l = W.label "Hello world" in
  let layout = L.flat_of_w [b;l] in

  let board = Bogue.of_layout layout in
  Bogue.run board;;

let () =
  main ();
  Bogue.quit ()]}

    This can be compiled to bytecode with

    {v
ocamlfind ocamlc -package bogue -linkpkg -o minimal -thread minimal.ml
v}

    and to native code with

    {v
ocamlfind ocamlopt -package bogue -linkpkg -o minimal -thread minimal.ml
v}

    Then execute the compiled code:

    {v
./minimal
v}

    A window should open which should look like this:

    {%html:<div class="figure"><img src="minimal.png"></div>%}

    You may also evaluate this code in a Toplevel! (for instance [utop], or in an [emacs] session...). Just insert

    {v
#thread;;
#require "bogue";;
v}

    at the top, then paste the example code above, and add [;;] at the end.

*)
